<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Man page generated from reStructuredText.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="mandoc.css" type="text/css" media="all"/>
  <title>QEMU(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">QEMU(1)</td>
    <td class="head-vol">QEMU</td>
    <td class="head-rtitle">QEMU(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">qemu - QEMU User Documentation</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 [options] [disk_image]
</pre>
</div>
<br/>
</div>
<br/>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The QEMU PC System emulator simulates the following
  peripherals:</p>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>i440FX host PCI bridge and PIIX3 PCI to ISA bridge</li>
  <li>Cirrus CLGD 5446 PCI VGA card or dummy VGA card with Bochs VESA extensions
      (hardware level, including all non standard modes).</li>
  <li>PS/2 mouse and keyboard</li>
  <li>2 PCI IDE interfaces with hard disk and CD-ROM support</li>
  <li>Floppy disk</li>
  <li>PCI and ISA network adapters</li>
  <li>Serial ports</li>
  <li>IPMI BMC, either and internal or external one</li>
  <li>Creative SoundBlaster 16 sound card</li>
  <li>ENSONIQ AudioPCI ES1370 sound card</li>
  <li>Intel 82801AA AC97 Audio compatible sound card</li>
  <li>Intel HD Audio Controller and HDA codec</li>
  <li>Adlib (OPL2) - Yamaha YM3812 compatible chip</li>
  <li>Gravis Ultrasound GF1 sound card</li>
  <li>CS4231A compatible sound card</li>
  <li>PC speaker</li>
  <li>PCI UHCI, OHCI, EHCI or XHCI USB controller and a virtual USB-1.1
    hub.</li>
</ul>
</div>
<br/>
<p class="Pp">SMP is supported with up to 255 CPUs.</p>
<p class="Pp">QEMU uses the PC BIOS from the Seabios project and the
    Plex86/Bochs LGPL VGA BIOS.</p>
<p class="Pp">QEMU uses YM3812 emulation by Tatsuyuki Satoh.</p>
<p class="Pp">QEMU uses GUS emulation (GUSEMU32
    <i>http://www.deinmeister.de/gusemu/</i>) by Tibor &quot;TS&quot;
    Sch&#x00FC;tz.</p>
<p class="Pp">Note that, by default, GUS shares IRQ(7) with parallel ports and
    so QEMU must be told to not have parallel ports to have working GUS.</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 dos.img -device gus -parallel none
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Alternatively:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 dos.img -device gus,irq=5
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Or some other unclaimed IRQ.</p>
<p class="Pp">CS4231A is the chip used in Windows Sound System and GUSMAX
    products</p>
<p class="Pp">The PC speaker audio device can be configured using the
    pcspk-audiodev machine property, i.e.</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 some.img -audiodev &lt;backend&gt;,id=&lt;name&gt; -machine pcspk-audiodev=&lt;name&gt;
</pre>
</div>
<br/>
</div>
<br/>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp">disk_image is a raw hard disk image for IDE hard disk 0. Some
    targets do not need a disk image.</p>
<section class="Ss">
<h2 class="Ss" id="Standard_options"><a class="permalink" href="#Standard_options">Standard
  options</a></h2>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="h"><a class="permalink" href="#h"><b><b>-h</b></b></a></dt>
  <dd>Display help and exit</dd>
  <dt id="version"><a class="permalink" href="#version"><b><b>-version</b></b></a></dt>
  <dd>Display version information and exit</dd>
  <dt id="machine"><a class="permalink" href="#machine"><b><b>-machine
    [type=]name[,prop=value[,...]]</b></b></a></dt>
  <dd>Select the emulated machine by name. Use <b>-machine help</b> to list
      available machines.
    <p class="Pp">For architectures which aim to support live migration
        compatibility across releases, each release will introduce a new
        versioned machine type. For example, the 2.8.0 release introduced
        machine types &quot;pc-i440fx-2.8&quot; and &quot;pc-q35-2.8&quot; for
        the x86_64/i686 architectures.</p>
    <p class="Pp">To allow live migration of guests from QEMU version 2.8.0, to
        QEMU version 2.9.0, the 2.9.0 version must support the
        &quot;pc-i440fx-2.8&quot; and &quot;pc-q35-2.8&quot; machines too. To
        allow users live migrating VMs to skip multiple intermediate releases
        when upgrading, new releases of QEMU will support machine types from
        many previous versions.</p>
    <p class="Pp">Supported machine properties are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="accel=accels1_:accels2_:...__"><a class="permalink" href="#accel=accels1_:accels2_:...__"><b><b>accel=accels1[:accels2[:...]]</b></b></a></dt>
  <dd>This is used to enable an accelerator. Depending on the target
      architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available. By
      default, tcg is used. If there is more than one accelerator specified, the
      next one is used if the previous one fails to initialize.</dd>
  <dt id="vmport=on_off_auto"><a class="permalink" href="#vmport=on_off_auto"><b><b>vmport=on|off|auto</b></b></a></dt>
  <dd>Enables emulation of VMWare IO port, for vmmouse etc. auto says to select
      the value based on accel. For accel=xen the default is off otherwise the
      default is on.</dd>
  <dt id="dump"><a class="permalink" href="#dump"><b><b>dump-guest-core=on|off</b></b></a></dt>
  <dd>Include guest memory in a core dump. The default is on.</dd>
  <dt id="mem"><a class="permalink" href="#mem"><b><b>mem-merge=on|off</b></b></a></dt>
  <dd>Enables or disables memory merge support. This feature, when supported by
      the host, de-duplicates identical memory pages among VMs instances
      (enabled by default).</dd>
  <dt id="aes"><a class="permalink" href="#aes"><b><b>aes-key-wrap=on|off</b></b></a></dt>
  <dd>Enables or disables AES key wrapping support on s390-ccw hosts. This
      feature controls whether AES wrapping keys will be created to allow
      execution of AES cryptographic functions. The default is on.</dd>
  <dt id="dea"><a class="permalink" href="#dea"><b><b>dea-key-wrap=on|off</b></b></a></dt>
  <dd>Enables or disables DEA key wrapping support on s390-ccw hosts. This
      feature controls whether DEA wrapping keys will be created to allow
      execution of DEA cryptographic functions. The default is on.</dd>
  <dt id="nvdimm=on_off"><a class="permalink" href="#nvdimm=on_off"><b><b>nvdimm=on|off</b></b></a></dt>
  <dd>Enables or disables NVDIMM support. The default is off.</dd>
  <dt id="memory"><a class="permalink" href="#memory"><b><b>memory-encryption=</b></b></a></dt>
  <dd>Memory encryption object to use. The default is none.</dd>
  <dt id="hmat=on_off"><a class="permalink" href="#hmat=on_off"><b><b>hmat=on|off</b></b></a></dt>
  <dd>Enables or disables ACPI Heterogeneous Memory Attribute Table (HMAT)
      support. The default is off.</dd>
  <dt id="memory~2"><a class="permalink" href="#memory~2"><b><b>memory-backend='id'</b></b></a></dt>
  <dd>An alternative to legacy <b>-mem-path</b> and <b>mem-prealloc</b> options.
      Allows to use a memory backend as main RAM.
    <p class="Pp">For example:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-object memory-backend-file,id=pc.ram,size=512M,mem-path=/hugetlbfs,prealloc=on,share=on
-machine memory-backend=pc.ram
-m 512M
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Migration compatibility note:</p>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>as backend id one shall use value of 'default-ram-id', advertised by
      machine type (available via <b>query-machines</b> QMP command), if
      migration to/from old QEMU (&lt;5.0) is expected.</li>
  <li>for machine types 4.0 and older, user shall use
      <b>x-use-canonical-path-for-ramblock-id=off</b> backend option if
      migration to/from old QEMU (&lt;5.0) is expected.</li>
</ul>
</div>
<br/>
<p class="Pp">For example:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-object memory-backend-ram,id=pc.ram,size=512M,x-use-canonical-path-for-ramblock-id=off
-machine memory-backend=pc.ram
-m 512M
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="sgx"><a class="permalink" href="#sgx"><b><b>sgx-epc.0.memdev=@var{memid},sgx-epc.0.node=@var{numaid}</b></b></a></dt>
  <dd>Define an SGX EPC section.</dd>
  <dt id="cpu"><a class="permalink" href="#cpu"><b><b>-cpu
    model</b></b></a></dt>
  <dd>Select CPU model (<b>-cpu help</b> for list and additional feature
      selection)</dd>
  <dt id="accel"><a class="permalink" href="#accel"><b><b>-accel
    name[,prop=value[,...]]</b></b></a></dt>
  <dd>This is used to enable an accelerator. Depending on the target
      architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available. By
      default, tcg is used. If there is more than one accelerator specified, the
      next one is used if the previous one fails to initialize.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="igd"><a class="permalink" href="#igd"><b><b>igd-passthru=on|off</b></b></a></dt>
  <dd>When Xen is in use, this option controls whether Intel integrated graphics
      devices can be passed through to the guest (default=off)</dd>
  <dt id="kernel"><a class="permalink" href="#kernel"><b><b>kernel-irqchip=on|off|split</b></b></a></dt>
  <dd>Controls KVM in-kernel irqchip support. The default is full acceleration
      of the interrupt controllers. On x86, split irqchip reduces the kernel
      attack surface, at a performance cost for non-MSI interrupts. Disabling
      the in-kernel irqchip completely is not recommended except for debugging
      purposes.</dd>
  <dt id="kvm"><a class="permalink" href="#kvm"><b><b>kvm-shadow-mem=size</b></b></a></dt>
  <dd>Defines the size of the KVM shadow MMU.</dd>
  <dt id="split"><a class="permalink" href="#split"><b><b>split-wx=on|off</b></b></a></dt>
  <dd>Controls the use of split w^x mapping for the TCG code generation buffer.
      Some operating systems require this to be enabled, and in such a case this
      will default on. On other operating systems, this will default off, but
      one may enable this for testing or debugging.</dd>
  <dt id="tb"><a class="permalink" href="#tb"><b><b>tb-size=n</b></b></a></dt>
  <dd>Controls the size (in MiB) of the TCG translation block cache.</dd>
  <dt id="thread=single_multi"><a class="permalink" href="#thread=single_multi"><b><b>thread=single|multi</b></b></a></dt>
  <dd>Controls number of TCG threads. When the TCG is multi-threaded there will
      be one thread per vCPU therefore taking advantage of additional host
      cores. The default is to enable multi-threading where both the back-end
      and front-ends support it and no incompatible TCG features have been
      enabled (e.g. icount/replay).</dd>
  <dt id="dirty"><a class="permalink" href="#dirty"><b><b>dirty-ring-size=n</b></b></a></dt>
  <dd>When the KVM accelerator is used, it controls the size of the per-vCPU
      dirty page ring buffer (number of entries for each vCPU). It should be a
      value that is power of two, and it should be 1024 or bigger (but still
      less than the maximum value that the kernel supports). 4096 could be a
      good initial value if you have no idea which is the best. Set this value
      to 0 to disable the feature. By default, this feature is disabled
      (dirty-ring-size=0). When enabled, KVM will instead record dirty pages in
      a bitmap.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="smp"><a class="permalink" href="#smp"><b><b>-smp
    [[cpus=]n][,maxcpus=maxcpus][,sockets=sockets][,dies=dies][,clusters=clusters][,cores=cores][,threads=threads]</b></b></a></dt>
  <dd>Simulate a SMP system with '<b>n</b>' CPUs initially present on the
      machine type board. On boards supporting CPU hotplug, the optional
      '<b>maxcpus</b>' parameter can be set to enable further CPUs to be added
      at runtime. When both parameters are omitted, the maximum number of CPUs
      will be calculated from the provided topology members and the initial CPU
      count will match the maximum number. When only one of them is given then
      the omitted one will be set to its counterpart's value. Both parameters
      may be specified, but the maximum number of CPUs must be equal to or
      greater than the initial CPU count. Product of the CPU topology hierarchy
      must be equal to the maximum number of CPUs. Both parameters are subject
      to an upper limit that is determined by the specific machine type chosen.
    <p class="Pp">To control reporting of CPU topology information, values of
        the topology parameters can be specified. Machines may only support a
        subset of the parameters and different machines may have different
        subsets supported which vary depending on capacity of the corresponding
        CPU targets. So for a particular machine type board, an expected
        topology hierarchy can be defined through the supported sub-option.
        Unsupported parameters can also be provided in addition to the
        sub-option, but their values must be set as 1 in the purpose of correct
        parsing.</p>
    <p class="Pp">Either the initial CPU count, or at least one of the topology
        parameters must be specified. The specified parameters must be greater
        than zero, explicit configuration like &quot;cpus=0&quot; is not
        allowed. Values for any omitted parameters will be computed from those
        which are given.</p>
    <p class="Pp">For example, the following sub-option defines a CPU topology
        hierarchy (2 sockets totally on the machine, 2 cores per socket, 2
        threads per core) for a machine that only supports
        sockets/cores/threads. Some members of the option can be omitted but
        their values will be automatically computed:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-smp 8,sockets=2,cores=2,threads=2,maxcpus=8
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">The following sub-option defines a CPU topology hierarchy (2
    sockets totally on the machine, 2 dies per socket, 2 cores per die, 2
    threads per core) for PC machines which support sockets/dies/cores/threads.
    Some members of the option can be omitted but their values will be
    automatically computed:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-smp 16,sockets=2,dies=2,cores=2,threads=2,maxcpus=16
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">The following sub-option defines a CPU topology hierarchy (2
    sockets totally on the machine, 2 clusters per socket, 2 cores per cluster,
    2 threads per core) for ARM virt machines which support sockets/clusters
    /cores/threads. Some members of the option can be omitted but their values
    will be automatically computed:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-smp 16,sockets=2,clusters=2,cores=2,threads=2,maxcpus=16
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Historically preference was given to the coarsest topology
    parameters when computing missing values (ie sockets preferred over cores,
    which were preferred over threads), however, this behaviour is considered
    liable to change. Prior to 6.2 the preference was sockets over cores over
    threads. Since 6.2 the preference is cores over sockets over threads.</p>
<p class="Pp">For example, the following option defines a machine board with 2
    sockets of 1 core before 6.2 and 1 socket of 2 cores after 6.2:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-smp 2
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="numa"><a class="permalink" href="#numa"><b><b>-numa
    node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="numa~2"><a class="permalink" href="#numa~2"><b><b>-numa
    node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="numa~3"><a class="permalink" href="#numa~3"><b><b>-numa
    dist,src=source,dst=destination,val=distance</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="numa~4"><a class="permalink" href="#numa~4"><b><b>-numa
    cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="numa~5"><a class="permalink" href="#numa~5"><b><b>-numa
    hmat-lb,initiator=node,target=node,hierarchy=hierarchy,data-type=tpye[,latency=lat][,bandwidth=bw]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="numa~6"><a class="permalink" href="#numa~6"><b><b>-numa
    hmat-cache,node-id=node,size=size,level=level[,associativity=str][,policy=str][,line=size]</b></b></a></dt>
  <dd>Define a NUMA node and assign RAM and VCPUs to it. Set the NUMA distance
      from a source node to a destination node. Set the ACPI Heterogeneous
      Memory Attributes for the given nodes.
    <p class="Pp">Legacy VCPU assignment uses '<b>cpus</b>' option where
        firstcpu and lastcpu are CPU indexes. Each '<b>cpus</b>' option
        represent a contiguous range of CPU indexes (or a single VCPU if lastcpu
        is omitted). A non-contiguous set of VCPUs can be represented by
        providing multiple '<b>cpus</b>' options. If '<b>cpus</b>' is omitted on
        all nodes, VCPUs are automatically split between them.</p>
    <p class="Pp">For example, the following option assigns VCPUs 0, 1, 2 and 5
        to a NUMA node:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-numa node,cpus=0-2,cpus=5
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">'<b>cpu</b>' option is a new alternative to '<b>cpus</b>' option
    which uses '<b>socket-id|core-id|thread-id</b>' properties to assign CPU
    objects to a node using topology layout properties of CPU. The set of
    properties is machine specific, and depends on used machine
    type/'<b>smp</b>' options. It could be queried with
    '<b>hotpluggable-cpus</b>' monitor command. '<b>node-id</b>' property
    specifies node to which CPU object will be assigned, it's required for node
    to be declared with '<b>node</b>' option before it's used with '<b>cpu</b>'
    option.</p>
<p class="Pp">For example:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-M pc \
-smp 1,sockets=2,maxcpus=2 \
-numa node,nodeid=0 -numa node,nodeid=1 \
-numa cpu,node-id=0,socket-id=0 -numa cpu,node-id=1,socket-id=1
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Legacy '<b>mem</b>' assigns a given RAM amount to a node (not
    supported for 5.1 and newer machine types). '<b>memdev</b>' assigns RAM from
    a given memory backend device to a node. If '<b>mem</b>' and '<b>memdev</b>'
    are omitted in all nodes, RAM is split equally between them.</p>
<p class="Pp">'<b>mem</b>' and '<b>memdev</b>' are mutually exclusive.
    Furthermore, if one node uses '<b>memdev</b>', all of them have to use
  it.</p>
<p class="Pp">'<b>initiator</b>' is an additional option that points to an
    initiator NUMA node that has best performance (the lowest latency or largest
    bandwidth) to this NUMA node. Note that this option can be set only when the
    machine property 'hmat' is set to 'on'.</p>
<p class="Pp">Following example creates a machine with 2 NUMA nodes, node 0 has
    CPU. node 1 has only memory, and its initiator is node 0. Note that because
    node 0 has CPU, by default the initiator of node 0 is itself and must be
    itself.</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-machine hmat=on \
-m 2G,slots=2,maxmem=4G \
-object memory-backend-ram,size=1G,id=m0 \
-object memory-backend-ram,size=1G,id=m1 \
-numa node,nodeid=0,memdev=m0 \
-numa node,nodeid=1,memdev=m1,initiator=0 \
-smp 2,sockets=2,maxcpus=2  \
-numa cpu,node-id=0,socket-id=0 \
-numa cpu,node-id=0,socket-id=1
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">source and destination are NUMA node IDs. distance is the NUMA
    distance from source to destination. The distance from a node to itself is
    always 10. If any pair of nodes is given a distance, then all pairs must be
    given distances. Although, when distances are only given in one direction
    for each pair of nodes, then the distances in the opposite directions are
    assumed to be the same. If, however, an asymmetrical pair of distances is
    given for even one node pair, then all node pairs must be provided distance
    values for both directions, even when they are symmetrical. When a node is
    unreachable from another node, set the pair's distance to 255.</p>
<p class="Pp">Note that the -<b>numa</b> option doesn't allocate any of the
    specified resources, it just assigns existing resources to NUMA nodes. This
    means that one still has to use the <b>-m</b>, <b>-smp</b> options to
    allocate RAM and VCPUs respectively.</p>
<p class="Pp">Use '<b>hmat-lb</b>' to set System Locality Latency and Bandwidth
    Information between initiator and target NUMA nodes in ACPI Heterogeneous
    Attribute Memory Table (HMAT). Initiator NUMA node can create memory
    requests, usually it has one or more processors. Target NUMA node contains
    addressable memory.</p>
<p class="Pp">In '<b>hmat-lb</b>' option, node are NUMA node IDs. hierarchy is
    the memory hierarchy of the target NUMA node: if hierarchy is 'memory', the
    structure represents the memory performance; if hierarchy is
    'first-level|second-level|third-level', this structure represents aggregated
    performance of memory side caches for each domain. type of 'data-type' is
    type of data represented by this structure instance: if 'hierarchy' is
    'memory', 'data-type' is 'access|read|write' latency or 'access|read|write'
    bandwidth of the target memory; if 'hierarchy' is
    'first-level|second-level|third-level', 'data-type' is 'access|read|write'
    hit latency or 'access|read|write' hit bandwidth of the target memory side
    cache.</p>
<p class="Pp">lat is latency value in nanoseconds. bw is bandwidth value, the
    possible value and units are NUM[M|G|T], mean that the bandwidth value are
    NUM byte per second (or MB/s, GB/s or TB/s depending on used suffix). Note
    that if latency or bandwidth value is 0, means the corresponding latency or
    bandwidth information is not provided.</p>
<p class="Pp">In '<b>hmat-cache</b>' option, node-id is the NUMA-id of the
    memory belongs. size is the size of memory side cache in bytes. level is the
    cache level described in this structure, note that the cache level 0 should
    not be used with '<b>hmat-cache</b>' option. associativity is the cache
    associativity, the possible value is
    'none/direct(direct-mapped)/complex(complex cache indexing)'. policy is the
    write policy. line is the cache Line size in bytes.</p>
<p class="Pp">For example, the following options describe 2 NUMA nodes. Node 0
    has 2 cpus and a ram, node 1 has only a ram. The processors in node 0 access
    memory in node 0 with access-latency 5 nanoseconds, access-bandwidth is 200
    MB/s; The processors in NUMA node 0 access memory in NUMA node 1 with
    access-latency 10 nanoseconds, access-bandwidth is 100 MB/s. And for memory
    side cache information, NUMA node 0 and 1 both have 1 level memory cache,
    size is 10KB, policy is write-back, the cache Line size is 8 bytes:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-machine hmat=on \
-m 2G \
-object memory-backend-ram,size=1G,id=m0 \
-object memory-backend-ram,size=1G,id=m1 \
-smp 2,sockets=2,maxcpus=2 \
-numa node,nodeid=0,memdev=m0 \
-numa node,nodeid=1,memdev=m1,initiator=0 \
-numa cpu,node-id=0,socket-id=0 \
-numa cpu,node-id=0,socket-id=1 \
-numa hmat-lb,initiator=0,target=0,hierarchy=memory,data-type=access-latency,latency=5 \
-numa hmat-lb,initiator=0,target=0,hierarchy=memory,data-type=access-bandwidth,bandwidth=200M \
-numa hmat-lb,initiator=0,target=1,hierarchy=memory,data-type=access-latency,latency=10 \
-numa hmat-lb,initiator=0,target=1,hierarchy=memory,data-type=access-bandwidth,bandwidth=100M \
-numa hmat-cache,node-id=0,size=10K,level=1,associativity=direct,policy=write-back,line=8 \
-numa hmat-cache,node-id=1,size=10K,level=1,associativity=direct,policy=write-back,line=8
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="add"><a class="permalink" href="#add"><b><b>-add-fd
    fd=fd,set=set[,opaque=opaque]</b></b></a></dt>
  <dd>Add a file descriptor to an fd set. Valid options are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="fd=fd"><a class="permalink" href="#fd=fd"><b><b>fd=fd</b></b></a></dt>
  <dd>This option defines the file descriptor of which a duplicate is added to
      fd set. The file descriptor cannot be stdin, stdout, or stderr.</dd>
  <dt id="set=set"><a class="permalink" href="#set=set"><b><b>set=set</b></b></a></dt>
  <dd>This option defines the ID of the fd set to add the file descriptor
    to.</dd>
  <dt id="opaque=opaque"><a class="permalink" href="#opaque=opaque"><b><b>opaque=opaque</b></b></a></dt>
  <dd>This option defines a free-form string that can be used to describe
    fd.</dd>
</dl>
</div>
<br/>
<p class="Pp">You can open an image using pre-opened file descriptors from an fd
    set:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 \
<br/>
 -add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot; \
<br/>
 -add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot; \
<br/>
 -drive file=/dev/fdset/2,index=0,media=disk
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="set"><a class="permalink" href="#set"><b><b>-set
    group.id.arg=value</b></b></a></dt>
  <dd>Set parameter arg for item id of type group</dd>
  <dt id="global"><a class="permalink" href="#global"><b><b>-global
    driver.prop=value</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="global~2"><a class="permalink" href="#global~2"><b><b>-global
    driver=driver,property=property,value=value</b></b></a></dt>
  <dd>Set default value of driver's property prop to value, e.g.:</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -global ide-hd.physical_block_size=4096 disk-image.img
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">In particular, you can use this to set driver properties for
    devices which are created automatically by the machine model. To create a
    device which is not created automatically and set properties on it, use
    -<b>device</b>.</p>
<p class="Pp">-global driver.prop=value is shorthand for -global
    driver=driver,property=prop,value=value. The longhand syntax works even when
    driver contains a dot.</p>
<dl class="Bl-tag">
  <dt id="boot"><a class="permalink" href="#boot"><b><b>-boot
    [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]</b></b></a></dt>
  <dd>Specify boot order drives as a string of drive letters. Valid drive
      letters depend on the target architecture. The x86 PC uses: a, b (floppy 1
      and 2), c (first hard disk), d (first CD-ROM), n-p (Etherboot from network
      adapter 1-4), hard disk boot is the default. To apply a particular boot
      order only on the first startup, specify it via <b>once</b>. Note that the
      <b>order</b> or <b>once</b> parameter should not be used together with the
      <b>bootindex</b> property of devices, since the firmware implementations
      normally do not support both at the same time.
    <p class="Pp">Interactive boot menus/prompts can be enabled via
        <b>menu=on</b> as far as firmware/BIOS supports them. The default is
        non-interactive boot.</p>
    <p class="Pp">A splash picture could be passed to bios, enabling user to
        show it as logo, when option splash=sp_name is given and menu=on, If
        firmware/BIOS supports them. Currently Seabios for X86 system support
        it. limitation: The splash file could be a jpeg file or a BMP file in 24
        BPP format(true color). The resolution should be supported by the SVGA
        mode, so the recommended is 320x240, 640x480, 800x640.</p>
    <p class="Pp">A timeout could be passed to bios, guest will pause for
        rb_timeout ms when boot failed, then reboot. If rb_timeout is '-1',
        guest will not reboot, qemu passes '-1' to bios by default. Currently
        Seabios for X86 system support it.</p>
    <p class="Pp">Do strict boot via <b>strict=on</b> as far as firmware/BIOS
        supports it. This only effects when boot priority is changed by
        bootindex options. The default is non-strict boot.</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># try to boot from network first, then from hard disk
qemu-system-x86_64 -boot order=nc
# boot from CD-ROM first, switch back to default order after reboot
qemu-system-x86_64 -boot once=d
# boot with a splash picture for 5 seconds.
qemu-system-x86_64 -boot menu=on,splash=/root/boot.bmp,splash-time=5000
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Note: The legacy format '-boot drives' is still supported but its
    use is discouraged as it may be removed from future versions.</p>
<dl class="Bl-tag">
  <dt id="m"><a class="permalink" href="#m"><b><b>-m
    [size=]megs[,slots=n,maxmem=size]</b></b></a></dt>
  <dd>Sets guest startup RAM size to megs megabytes. Default is 128 MiB.
      Optionally, a suffix of &quot;M&quot; or &quot;G&quot; can be used to
      signify a value in megabytes or gigabytes respectively. Optional pair
      slots, maxmem could be used to set amount of hotpluggable memory slots and
      maximum amount of memory. Note that maxmem must be aligned to the page
      size.
    <p class="Pp">For example, the following command-line sets the guest startup
        RAM size to 1GB, creates 3 slots to hotplug additional memory and sets
        the maximum memory the guest can reach to 4GB:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -m 1G,slots=3,maxmem=4G
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">If slots and maxmem are not specified, memory hotplug won't be
    enabled and the guest startup RAM will never increase.</p>
<dl class="Bl-tag">
  <dt id="mem~2"><a class="permalink" href="#mem~2"><b><b>-mem-path
    path</b></b></a></dt>
  <dd>Allocate guest RAM from a temporarily created file in path.</dd>
  <dt id="mem~3"><a class="permalink" href="#mem~3"><b><b>-mem-prealloc</b></b></a></dt>
  <dd>Preallocate memory when using -mem-path.</dd>
  <dt id="k"><a class="permalink" href="#k"><b><b>-k language</b></b></a></dt>
  <dd>Use keyboard layout language (for example <b>fr</b> for French). This
      option is only needed where it is not easy to get raw PC keycodes (e.g. on
      Macs, with some X11 servers or with a VNC or curses display). You don't
      normally need to use it on PC/Linux or PC/Windows hosts.
    <p class="Pp">The available layouts are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>ar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv
da  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th
de  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">The default is <b>en-us</b>.</p>
<dl class="Bl-tag">
  <dt id="audio"><a class="permalink" href="#audio"><b><b>-audio-help</b></b></a></dt>
  <dd>Will show the -audiodev equivalent of the currently specified (deprecated)
      environment variables.</dd>
  <dt id="audiodev"><a class="permalink" href="#audiodev"><b><b>-audiodev
    [driver=]driver,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Adds a new audio backend driver identified by id. There are global and
      driver specific properties. Some values can be set differently for input
      and output, they're marked with <b>in|out.</b>. You can set the input's
      property with <b>in.prop</b> and the output's property with
      <b>out.prop</b>. For example:</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-audiodev alsa,id=example,in.frequency=44110,out.frequency=8000
-audiodev alsa,id=example,out.channels=1 # leaves in.channels unspecified
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">NOTE: parameter validation is known to be incomplete, in many
    cases specifying an invalid option causes QEMU to print an error message and
    continue emulation without sound.</p>
<p class="Pp">Valid global options are:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="id=identifier"><a class="permalink" href="#id=identifier"><b><b>id=identifier</b></b></a></dt>
  <dd>Identifies the audio backend.</dd>
  <dt id="timer"><a class="permalink" href="#timer"><b><b>timer-period=period</b></b></a></dt>
  <dd>Sets the timer period used by the audio subsystem in microseconds. Default
      is 10000 (10 ms).</dd>
  <dt id="in_out.mixing"><a class="permalink" href="#in_out.mixing"><b><b>in|out.mixing-engine=on|off</b></b></a></dt>
  <dd>Use QEMU's mixing engine to mix all streams inside QEMU and convert audio
      formats when not supported by the backend. When off, fixed-settings must
      be off too. Note that disabling this option means that the selected
      backend must support multiple streams and the audio formats used by the
      virtual cards, otherwise you'll get no sound. It's not recommended to
      disable this option unless you want to use 5.1 or 7.1 audio, as mixing
      engine only supports mono and stereo audio. Default is on.</dd>
  <dt id="in_out.fixed"><a class="permalink" href="#in_out.fixed"><b><b>in|out.fixed-settings=on|off</b></b></a></dt>
  <dd>Use fixed settings for host audio. When off, it will change based on how
      the guest opens the sound card. In this case you must not specify
      frequency, channels or format. Default is on.</dd>
  <dt id="in_out.frequency=frequency"><a class="permalink" href="#in_out.frequency=frequency"><b><b>in|out.frequency=frequency</b></b></a></dt>
  <dd>Specify the frequency to use when using fixed-settings. Default is
      44100Hz.</dd>
  <dt id="in_out.channels=channels"><a class="permalink" href="#in_out.channels=channels"><b><b>in|out.channels=channels</b></b></a></dt>
  <dd>Specify the number of channels to use when using fixed-settings. Default
      is 2 (stereo).</dd>
  <dt id="in_out.format=format"><a class="permalink" href="#in_out.format=format"><b><b>in|out.format=format</b></b></a></dt>
  <dd>Specify the sample format to use when using fixed-settings. Valid values
      are: <b>s8</b>, <b>s16</b>, <b>s32</b>, <b>u8</b>, <b>u16</b>, <b>u32</b>,
      <b>f32</b>. Default is <b>s16</b>.</dd>
  <dt id="in_out.voices=voices"><a class="permalink" href="#in_out.voices=voices"><b><b>in|out.voices=voices</b></b></a></dt>
  <dd>Specify the number of voices to use. Default is 1.</dd>
  <dt id="in_out.buffer"><a class="permalink" href="#in_out.buffer"><b><b>in|out.buffer-length=usecs</b></b></a></dt>
  <dd>Sets the size of the buffer in microseconds.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="audiodev~2"><a class="permalink" href="#audiodev~2"><b><b>-audiodev
    none,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Creates a dummy backend that discards all outputs. This backend has no
      backend specific properties.</dd>
  <dt id="audiodev~3"><a class="permalink" href="#audiodev~3"><b><b>-audiodev
    alsa,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Creates backend using the ALSA. This backend is only available on Linux.
    <p class="Pp">ALSA specific options are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="in_out.dev=device"><a class="permalink" href="#in_out.dev=device"><b><b>in|out.dev=device</b></b></a></dt>
  <dd>Specify the ALSA device to use for input and/or output. Default is
      <b>default</b>.</dd>
  <dt id="in_out.period"><a class="permalink" href="#in_out.period"><b><b>in|out.period-length=usecs</b></b></a></dt>
  <dd>Sets the period length in microseconds.</dd>
  <dt id="in_out.try"><a class="permalink" href="#in_out.try"><b><b>in|out.try-poll=on|off</b></b></a></dt>
  <dd>Attempt to use poll mode with the device. Default is on.</dd>
  <dt id="threshold=threshold"><a class="permalink" href="#threshold=threshold"><b><b>threshold=threshold</b></b></a></dt>
  <dd>Threshold (in microseconds) when playback starts. Default is 0.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="audiodev~4"><a class="permalink" href="#audiodev~4"><b><b>-audiodev
    coreaudio,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Creates a backend using Apple's Core Audio. This backend is only available
      on Mac OS and only supports playback.
    <p class="Pp">Core Audio specific options are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="in_out.buffer~2"><a class="permalink" href="#in_out.buffer~2"><b><b>in|out.buffer-count=count</b></b></a></dt>
  <dd>Sets the count of the buffers.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="audiodev~5"><a class="permalink" href="#audiodev~5"><b><b>-audiodev
    dsound,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Creates a backend using Microsoft's DirectSound. This backend is only
      available on Windows and only supports playback.
    <p class="Pp">DirectSound specific options are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="latency=usecs"><a class="permalink" href="#latency=usecs"><b><b>latency=usecs</b></b></a></dt>
  <dd>Add extra usecs microseconds latency to playback. Default is 10000 (10
      ms).</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="audiodev~6"><a class="permalink" href="#audiodev~6"><b><b>-audiodev
    oss,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Creates a backend using OSS. This backend is available on most Unix-like
      systems.
    <p class="Pp">OSS specific options are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="in_out.dev=device~2"><a class="permalink" href="#in_out.dev=device~2"><b><b>in|out.dev=device</b></b></a></dt>
  <dd>Specify the file name of the OSS device to use. Default is
      <b>/dev/dsp</b>.</dd>
  <dt id="in_out.buffer~3"><a class="permalink" href="#in_out.buffer~3"><b><b>in|out.buffer-count=count</b></b></a></dt>
  <dd>Sets the count of the buffers.</dd>
  <dt id="in_out.try~2"><a class="permalink" href="#in_out.try~2"><b><b>in|out.try-poll=on|of</b></b></a></dt>
  <dd>Attempt to use poll mode with the device. Default is on.</dd>
  <dt id="try"><a class="permalink" href="#try"><b><b>try-mmap=on|off</b></b></a></dt>
  <dd>Try using memory mapped device access. Default is off.</dd>
  <dt id="exclusive=on_off"><a class="permalink" href="#exclusive=on_off"><b><b>exclusive=on|off</b></b></a></dt>
  <dd>Open the device in exclusive mode (vmix won't work in this case). Default
      is off.</dd>
  <dt id="dsp"><a class="permalink" href="#dsp"><b><b>dsp-policy=policy</b></b></a></dt>
  <dd>Sets the timing policy (between 0 and 10, where smaller number means
      smaller latency but higher CPU usage). Use -1 to use buffer sizes
      specified by <b>buffer</b> and <b>buffer-count</b>. This option is ignored
      if you do not have OSS 4. Default is 5.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="audiodev~7"><a class="permalink" href="#audiodev~7"><b><b>-audiodev
    pa,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Creates a backend using PulseAudio. This backend is available on most
      systems.
    <p class="Pp">PulseAudio specific options are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="server=server"><a class="permalink" href="#server=server"><b><b>server=server</b></b></a></dt>
  <dd>Sets the PulseAudio server to connect to.</dd>
  <dt id="in_out.name=sink"><a class="permalink" href="#in_out.name=sink"><b><b>in|out.name=sink</b></b></a></dt>
  <dd>Use the specified source/sink for recording/playback.</dd>
  <dt id="in_out.latency=usecs"><a class="permalink" href="#in_out.latency=usecs"><b><b>in|out.latency=usecs</b></b></a></dt>
  <dd>Desired latency in microseconds. The PulseAudio server will try to honor
      this value but actual latencies may be lower or higher.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="audiodev~8"><a class="permalink" href="#audiodev~8"><b><b>-audiodev
    sdl,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Creates a backend using SDL. This backend is available on most systems,
      but you should use your platform's native backend if possible.
    <p class="Pp">SDL specific options are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="in_out.buffer~4"><a class="permalink" href="#in_out.buffer~4"><b><b>in|out.buffer-count=count</b></b></a></dt>
  <dd>Sets the count of the buffers.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="audiodev~9"><a class="permalink" href="#audiodev~9"><b><b>-audiodev
    spice,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Creates a backend that sends audio through SPICE. This backend requires
      <b>-spice</b> and automatically selected in that case, so usually you can
      ignore this option. This backend has no backend specific properties.</dd>
  <dt id="audiodev~10"><a class="permalink" href="#audiodev~10"><b><b>-audiodev
    wav,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Creates a backend that writes audio to a WAV file.
    <p class="Pp">Backend specific options are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="path=path"><a class="permalink" href="#path=path"><b><b>path=path</b></b></a></dt>
  <dd>Write recorded audio into the specified file. Default is
    <b>qemu.wav</b>.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="soundhw"><a class="permalink" href="#soundhw"><b><b>-soundhw
    card1[,card2,...] or -soundhw all</b></b></a></dt>
  <dd>Enable audio and selected sound hardware. Use 'help' to print all
      available sound hardware. For example:</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -soundhw sb16,adlib disk.img
qemu-system-x86_64 -soundhw es1370 disk.img
qemu-system-x86_64 -soundhw ac97 disk.img
qemu-system-x86_64 -soundhw hda disk.img
qemu-system-x86_64 -soundhw all disk.img
qemu-system-x86_64 -soundhw help
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Note that Linux's i810_audio OSS kernel (for AC97) module might
    require manually specifying clocking.</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>modprobe i810_audio clocking=48000
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="device"><a class="permalink" href="#device"><b><b>-device
    driver[,prop[=value][,...]]</b></b></a></dt>
  <dd>Add device driver. prop=value sets driver properties. Valid properties
      depend on the driver. To get help on possible drivers and properties, use
      <b>-device help</b> and <b>-device driver,help</b>.
    <p class="Pp">Some drivers are:</p>
  </dd>
  <dt id="device~2"><a class="permalink" href="#device~2"><b><b>-device
    ipmi-bmc-sim,id=id[,prop[=value][,...]]</b></b></a></dt>
  <dd>Add an IPMI BMC. This is a simulation of a hardware management interface
      processor that normally sits on a system. It provides a watchdog and the
      ability to reset and power control the system. You need to connect this to
      an IPMI interface to make it useful
    <p class="Pp">The IPMI slave address to use for the BMC. The default is
        0x20. This address is the BMC's address on the I2C network of management
        controllers. If you don't know what this means, it is safe to ignore
      it.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="id=id"><a class="permalink" href="#id=id"><b><b>id=id</b></b></a></dt>
  <dd>The BMC id for interfaces to use this device.</dd>
  <dt id="slave_addr=val"><a class="permalink" href="#slave_addr=val"><b><b>slave_addr=val</b></b></a></dt>
  <dd>Define slave address to use for the BMC. The default is 0x20.</dd>
  <dt id="sdrfile=file"><a class="permalink" href="#sdrfile=file"><b><b>sdrfile=file</b></b></a></dt>
  <dd>file containing raw Sensor Data Records (SDR) data. The default is
    none.</dd>
  <dt id="fruareasize=val"><a class="permalink" href="#fruareasize=val"><b><b>fruareasize=val</b></b></a></dt>
  <dd>size of a Field Replaceable Unit (FRU) area. The default is 1024.</dd>
  <dt id="frudatafile=file"><a class="permalink" href="#frudatafile=file"><b><b>frudatafile=file</b></b></a></dt>
  <dd>file containing raw Field Replaceable Unit (FRU) inventory data. The
      default is none.</dd>
  <dt id="guid=uuid"><a class="permalink" href="#guid=uuid"><b><b>guid=uuid</b></b></a></dt>
  <dd>value for the GUID for the BMC, in standard UUID format. If this is set,
      get &quot;Get GUID&quot; command to the BMC will return it. Otherwise
      &quot;Get GUID&quot; will return an error.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="device~3"><a class="permalink" href="#device~3"><b><b>-device
    ipmi-bmc-extern,id=id,chardev=id[,slave_addr=val]</b></b></a></dt>
  <dd>Add a connection to an external IPMI BMC simulator. Instead of locally
      emulating the BMC like the above item, instead connect to an external
      entity that provides the IPMI services.
    <p class="Pp">A connection is made to an external BMC simulator. If you do
        this, it is strongly recommended that you use the &quot;reconnect=&quot;
        chardev option to reconnect to the simulator if the connection is lost.
        Note that if this is not used carefully, it can be a security issue, as
        the interface has the ability to send resets, NMIs, and power off the
        VM. It's best if QEMU makes a connection to an external simulator
        running on a secure port on localhost, so neither the simulator nor QEMU
        is exposed to any outside network.</p>
    <p class="Pp">See the &quot;lanserv/README.vm&quot; file in the OpenIPMI
        library for more details on the external interface.</p>
  </dd>
  <dt id="device~4"><a class="permalink" href="#device~4"><b><b>-device
    isa-ipmi-kcs,bmc=id[,ioport=val][,irq=val]</b></b></a></dt>
  <dd>Add a KCS IPMI interafce on the ISA bus. This also adds a corresponding
      ACPI and SMBIOS entries, if appropriate.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="bmc=id"><a class="permalink" href="#bmc=id"><b><b>bmc=id</b></b></a></dt>
  <dd>The BMC to connect to, one of ipmi-bmc-sim or ipmi-bmc-extern above.</dd>
  <dt id="ioport=val"><a class="permalink" href="#ioport=val"><b><b>ioport=val</b></b></a></dt>
  <dd>Define the I/O address of the interface. The default is 0xca0 for
    KCS.</dd>
  <dt id="irq=val"><a class="permalink" href="#irq=val"><b><b>irq=val</b></b></a></dt>
  <dd>Define the interrupt to use. The default is 5. To disable interrupts, set
      this to 0.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="device~5"><a class="permalink" href="#device~5"><b><b>-device
    isa-ipmi-bt,bmc=id[,ioport=val][,irq=val]</b></b></a></dt>
  <dd>Like the KCS interface, but defines a BT interface. The default port is
      0xe4 and the default interrupt is 5.</dd>
  <dt id="device~6"><a class="permalink" href="#device~6"><b><b>-device
    pci-ipmi-kcs,bmc=id</b></b></a></dt>
  <dd>Add a KCS IPMI interafce on the PCI bus.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="bmc=id~2"><a class="permalink" href="#bmc=id~2"><b><b>bmc=id</b></b></a></dt>
  <dd>The BMC to connect to, one of ipmi-bmc-sim or ipmi-bmc-extern above.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="device~7"><a class="permalink" href="#device~7"><b><b>-device
    pci-ipmi-bt,bmc=id</b></b></a></dt>
  <dd>Like the KCS interface, but defines a BT interface on the PCI bus.</dd>
  <dt id="device~8"><a class="permalink" href="#device~8"><b><b>-device
    intel-iommu[,option=...]</b></b></a></dt>
  <dd>This is only supported by <b>-machine q35</b>, which will enable Intel
      VT-d emulation within the guest. It supports below options:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="intremap=on_off"><a class="permalink" href="#intremap=on_off"><b><b>intremap=on|off</b>
    (default: auto)</b></a></dt>
  <dd>This enables interrupt remapping feature. It's required to enable complete
      x2apic. Currently it only supports kvm kernel-irqchip modes <b>off</b> or
      <b>split</b>, while full kernel-irqchip is not yet supported. The default
      value is &quot;auto&quot;, which will be decided by the mode of
      kernel-irqchip.</dd>
  <dt id="caching"><a class="permalink" href="#caching"><b><b>caching-mode=on|off</b>
    (default: off)</b></a></dt>
  <dd>This enables caching mode for the VT-d emulated device. When caching-mode
      is enabled, each guest DMA buffer mapping will generate an IOTLB
      invalidation from the guest IOMMU driver to the vIOMMU device in a
      synchronous way. It is required for <b>-device vfio-pci</b> to work with
      the VT-d device, because host assigned devices requires to setup the DMA
      mapping on the host before guest DMA starts.</dd>
  <dt id="device~9"><a class="permalink" href="#device~9"><b><b>device-iotlb=on|off</b>
    (default: off)</b></a></dt>
  <dd>This enables device-iotlb capability for the emulated VT-d device. So far
      virtio/vhost should be the only real user for this parameter, paired with
      ats=on configured for the device.</dd>
  <dt id="aw"><a class="permalink" href="#aw"><b><b>aw-bits=39|48</b> (default:
    39)</b></a></dt>
  <dd>This decides the address width of IOVA address space. The address space
      has 39 bits width for 3-level IOMMU page tables, and 48 bits for 4-level
      IOMMU page tables.</dd>
</dl>
</div>
<br/>
<p class="Pp">Please also refer to the wiki page for general scenarios of VT-d
    emulation in QEMU: <i>https://wiki.qemu.org/Features/VT-d</i>.</p>
<dl class="Bl-tag">
  <dt id="name"><a class="permalink" href="#name"><b><b>-name
    name</b></b></a></dt>
  <dd>Sets the name of the guest. This name will be displayed in the SDL window
      caption. The name will also be used for the VNC server. Also optionally
      set the top visible process name in Linux. Naming of individual threads
      can also be enabled on Linux to aid debugging.</dd>
  <dt id="uuid"><a class="permalink" href="#uuid"><b><b>-uuid
    uuid</b></b></a></dt>
  <dd>Set system UUID.</dd>
</dl>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Block_device_options"><a class="permalink" href="#Block_device_options">Block
  device options</a></h2>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="fda"><a class="permalink" href="#fda"><b><b>-fda file</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="fdb"><a class="permalink" href="#fdb"><b><b>-fdb file</b></b></a></dt>
  <dd>Use file as floppy disk 0/1 image (see the <i>Disk Images</i> chapter in
      the System Emulation Users Guide).</dd>
  <dt id="hda"><a class="permalink" href="#hda"><b><b>-hda file</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="hdb"><a class="permalink" href="#hdb"><b><b>-hdb file</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="hdc"><a class="permalink" href="#hdc"><b><b>-hdc file</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="hdd"><a class="permalink" href="#hdd"><b><b>-hdd file</b></b></a></dt>
  <dd>Use file as hard disk 0, 1, 2 or 3 image (see the <i>Disk Images</i>
      chapter in the System Emulation Users Guide).</dd>
  <dt id="cdrom"><a class="permalink" href="#cdrom"><b><b>-cdrom
    file</b></b></a></dt>
  <dd>Use file as CD-ROM image (you cannot use <b>-hdc</b> and <b>-cdrom</b> at
      the same time). You can use the host CD-ROM by using <b>/dev/cdrom</b> as
      filename.</dd>
  <dt id="blockdev"><a class="permalink" href="#blockdev"><b><b>-blockdev
    option[,option[,option[,...]]]</b></b></a></dt>
  <dd>Define a new block driver node. Some of the options apply to all block
      drivers, other options are only accepted for a specific block driver. See
      below for a list of generic options and options for the most common block
      drivers.
    <p class="Pp">Options that expect a reference to another node (e.g.
        <b>file</b>) can be given in two ways. Either you specify the node name
        of an already existing node (file=node-name), or you define a new node
        inline, adding options for the referenced node after a dot
        (file.filename=path,file.aio=native).</p>
    <p class="Pp">A block driver node created with <b>-blockdev</b> can be used
        for a guest device by specifying its node name for the <b>drive</b>
        property in a <b>-device</b> argument that defines a block device.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Valid"><a class="permalink" href="#Valid"><b><b>Valid options for any
    block driver node:</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="driver"><a class="permalink" href="#driver"><b><b>driver</b></b></a></dt>
  <dd>Specifies the block driver to use for the given node.</dd>
  <dt id="node"><a class="permalink" href="#node"><b><b>node-name</b></b></a></dt>
  <dd>This defines the name of the block driver node by which it will be
      referenced later. The name must be unique, i.e. it must not match the name
      of a different block driver node, or (if you use <b>-drive</b> as well)
      the ID of a drive.
    <p class="Pp">If no node name is specified, it is automatically generated.
        The generated node name is not intended to be predictable and changes
        between QEMU invocations. For the top level, an explicit node name must
        be specified.</p>
  </dd>
  <dt id="read"><a class="permalink" href="#read"><b><b>read-only</b></b></a></dt>
  <dd>Open the node read-only. Guest write attempts will fail.
    <p class="Pp">Note that some block drivers support only read-only access,
        either generally or in certain configurations. In this case, the default
        value <b>read-only=off</b> does not work and the option must be
        specified explicitly.</p>
  </dd>
  <dt id="auto"><a class="permalink" href="#auto"><b><b>auto-read-only</b></b></a></dt>
  <dd>If <b>auto-read-only=on</b> is set, QEMU may fall back to read-only usage
      even when <b>read-only=off</b> is requested, or even switch between modes
      as needed, e.g. depending on whether the image file is writable or whether
      a writing user is attached to the node.</dd>
  <dt id="force"><a class="permalink" href="#force"><b><b>force-share</b></b></a></dt>
  <dd>Override the image locking system of QEMU by forcing the node to utilize
      weaker shared access for permissions where it would normally request
      exclusive access. When there is the potential for multiple instances to
      have the same file open (whether this invocation of QEMU is the first or
      the second instance), both instances must permit shared access for the
      second instance to succeed at opening the file.
    <p class="Pp">Enabling <b>force-share=on</b> requires
      <b>read-only=on</b>.</p>
  </dd>
  <dt id="cache.direct"><a class="permalink" href="#cache.direct"><b><b>cache.direct</b></b></a></dt>
  <dd>The host page cache can be avoided with <b>cache.direct=on</b>. This will
      attempt to do disk IO directly to the guest's memory. QEMU may still
      perform an internal copy of the data.</dd>
  <dt id="cache.no"><a class="permalink" href="#cache.no"><b><b>cache.no-flush</b></b></a></dt>
  <dd>In case you don't care about data integrity over host failures, you can
      use <b>cache.no-flush=on</b>. This option tells QEMU that it never needs
      to write any data to the disk but can instead keep things in cache. If
      anything goes wrong, like your host losing power, the disk storage getting
      disconnected accidentally, etc. your image will most probably be rendered
      unusable.</dd>
  <dt id="discard=discard"><a class="permalink" href="#discard=discard"><b><b>discard=discard</b></b></a></dt>
  <dd>discard is one of &quot;ignore&quot; (or &quot;off&quot;) or
      &quot;unmap&quot; (or &quot;on&quot;) and controls whether <b>discard</b>
      (also known as <b>trim</b> or <b>unmap</b>) requests are ignored or passed
      to the filesystem. Some machine types may not support discard
    requests.</dd>
  <dt id="detect"><a class="permalink" href="#detect"><b><b>detect-zeroes=detect-zeroes</b></b></a></dt>
  <dd>detect-zeroes is &quot;off&quot;, &quot;on&quot; or &quot;unmap&quot; and
      enables the automatic conversion of plain zero writes by the OS to driver
      specific optimized zero write commands. You may even choose
      &quot;unmap&quot; if discard is set to &quot;unmap&quot; to allow a zero
      write to be converted to an <b>unmap</b> operation.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="Driver"><a class="permalink" href="#Driver"><b><b>Driver-specific
    options for file</b></b></a></dt>
  <dd>This is the protocol-level block driver for accessing regular files.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="filename"><a class="permalink" href="#filename"><b><b>filename</b></b></a></dt>
  <dd>The path to the image file in the local filesystem</dd>
  <dt id="aio"><a class="permalink" href="#aio"><b><b>aio</b></b></a></dt>
  <dd>Specifies the AIO backend (threads/native/io_uring, default: threads)</dd>
  <dt id="locking"><a class="permalink" href="#locking"><b><b>locking</b></b></a></dt>
  <dd>Specifies whether the image file is protected with Linux OFD / POSIX
      locks. The default is to use the Linux Open File Descriptor API if
      available, otherwise no lock is applied. (auto/on/off, default: auto)</dd>
</dl>
</div>
<br/>
<p class="Pp">Example:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-blockdev driver=file,node-name=disk,filename=disk.img
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="Driver~2"><a class="permalink" href="#Driver~2"><b><b>Driver-specific
    options for raw</b></b></a></dt>
  <dd>This is the image format block driver for raw images. It is usually
      stacked on top of a protocol level block driver such as <b>file</b>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="file"><a class="permalink" href="#file"><b><b>file</b></b></a></dt>
  <dd>Reference to or definition of the data source block driver node (e.g. a
      <b>file</b> driver node)</dd>
</dl>
</div>
<br/>
<p class="Pp">Example 1:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-blockdev driver=file,node-name=disk_file,filename=disk.img
-blockdev driver=raw,node-name=disk,file=disk_file
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example 2:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-blockdev driver=raw,node-name=disk,file.driver=file,file.filename=disk.img
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="Driver~3"><a class="permalink" href="#Driver~3"><b><b>Driver-specific
    options for qcow2</b></b></a></dt>
  <dd>This is the image format block driver for qcow2 images. It is usually
      stacked on top of a protocol level block driver such as <b>file</b>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="file~2"><a class="permalink" href="#file~2"><b><b>file</b></b></a></dt>
  <dd>Reference to or definition of the data source block driver node (e.g. a
      <b>file</b> driver node)</dd>
  <dt id="backing"><a class="permalink" href="#backing"><b><b>backing</b></b></a></dt>
  <dd>Reference to or definition of the backing file block device (default is
      taken from the image file). It is allowed to pass <b>null</b> here in
      order to disable the default backing file.</dd>
  <dt id="lazy"><a class="permalink" href="#lazy"><b><b>lazy-refcounts</b></b></a></dt>
  <dd>Whether to enable the lazy refcounts feature (on/off; default is taken
      from the image file)</dd>
  <dt id="cache"><a class="permalink" href="#cache"><b><b>cache-size</b></b></a></dt>
  <dd>The maximum total size of the L2 table and refcount block caches in bytes
      (default: the sum of l2-cache-size and refcount-cache-size)</dd>
  <dt id="l2"><a class="permalink" href="#l2"><b><b>l2-cache-size</b></b></a></dt>
  <dd>The maximum size of the L2 table cache in bytes (default: if cache-size is
      not specified - 32M on Linux platforms, and 8M on non-Linux platforms;
      otherwise, as large as possible within the cache-size, while permitting
      the requested or the minimal refcount cache size)</dd>
  <dt id="refcount"><a class="permalink" href="#refcount"><b><b>refcount-cache-size</b></b></a></dt>
  <dd>The maximum size of the refcount block cache in bytes (default: 4 times
      the cluster size; or if cache-size is specified, the part of it which is
      not used for the L2 cache)</dd>
  <dt id="cache~2"><a class="permalink" href="#cache~2"><b><b>cache-clean-interval</b></b></a></dt>
  <dd>Clean unused entries in the L2 and refcount caches. The interval is in
      seconds. The default value is 600 on supporting platforms, and 0 on other
      platforms. Setting it to 0 disables this feature.</dd>
  <dt id="pass"><a class="permalink" href="#pass"><b><b>pass-discard-request</b></b></a></dt>
  <dd>Whether discard requests to the qcow2 device should be forwarded to the
      data source (on/off; default: on if discard=unmap is specified, off
      otherwise)</dd>
  <dt id="pass~2"><a class="permalink" href="#pass~2"><b><b>pass-discard-snapshot</b></b></a></dt>
  <dd>Whether discard requests for the data source should be issued when a
      snapshot operation (e.g. deleting a snapshot) frees clusters in the qcow2
      file (on/off; default: on)</dd>
  <dt id="pass~3"><a class="permalink" href="#pass~3"><b><b>pass-discard-other</b></b></a></dt>
  <dd>Whether discard requests for the data source should be issued on other
      occasions where a cluster gets freed (on/off; default: off)</dd>
  <dt id="overlap"><a class="permalink" href="#overlap"><b><b>overlap-check</b></b></a></dt>
  <dd>Which overlap checks to perform for writes to the image
      (none/constant/cached/all; default: cached). For details or finer
      granularity control refer to the QAPI documentation of
      <b>blockdev-add</b>.</dd>
</dl>
</div>
<br/>
<p class="Pp">Example 1:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-blockdev driver=file,node-name=my_file,filename=/tmp/disk.qcow2
-blockdev driver=qcow2,node-name=hda,file=my_file,overlap-check=none,cache-size=16777216
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example 2:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-blockdev driver=qcow2,node-name=disk,file.driver=http,file.filename=http://example.com/image.qcow2
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="Driver~4"><a class="permalink" href="#Driver~4"><b><b>Driver-specific
    options for other drivers</b></b></a></dt>
  <dd>Please refer to the QAPI documentation of the <b>blockdev-add</b> QMP
      command.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="drive"><a class="permalink" href="#drive"><b><b>-drive
    option[,option[,option[,...]]]</b></b></a></dt>
  <dd>Define a new drive. This includes creating a block driver node (the
      backend) as well as a guest device, and is mostly a shortcut for defining
      the corresponding <b>-blockdev</b> and <b>-device</b> options.
    <p class="Pp"><b>-drive</b> accepts all options that are accepted by
        <b>-blockdev</b>. In addition, it knows the following options:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="file=file"><a class="permalink" href="#file=file"><b><b>file=file</b></b></a></dt>
  <dd>This option defines which disk image (see the <i>Disk Images</i> chapter
      in the System Emulation Users Guide) to use with this drive. If the
      filename contains comma, you must double it (for instance,
      &quot;file=my,,file&quot; to use file &quot;my,file&quot;).
    <p class="Pp">Special files such as iSCSI devices can be specified using
        protocol specific URLs. See the section for &quot;Device URL
        Syntax&quot; for more information.</p>
  </dd>
  <dt id="if=interface"><a class="permalink" href="#if=interface"><b><b>if=interface</b></b></a></dt>
  <dd>This option defines on which type on interface the drive is connected.
      Available types are: ide, scsi, sd, mtd, floppy, pflash, virtio,
    none.</dd>
  <dt id="bus=bus,unit=unit"><a class="permalink" href="#bus=bus,unit=unit"><b><b>bus=bus,unit=unit</b></b></a></dt>
  <dd>These options define where is connected the drive by defining the bus
      number and the unit id.</dd>
  <dt id="index=index"><a class="permalink" href="#index=index"><b><b>index=index</b></b></a></dt>
  <dd>This option defines where the drive is connected by using an index in the
      list of available connectors of a given interface type.</dd>
  <dt id="media=media"><a class="permalink" href="#media=media"><b><b>media=media</b></b></a></dt>
  <dd>This option defines the type of the media: disk or cdrom.</dd>
  <dt id="snapshot=snapshot"><a class="permalink" href="#snapshot=snapshot"><b><b>snapshot=snapshot</b></b></a></dt>
  <dd>snapshot is &quot;on&quot; or &quot;off&quot; and controls snapshot mode
      for the given drive (see <b>-snapshot</b>).</dd>
  <dt id="cache=cache"><a class="permalink" href="#cache=cache"><b><b>cache=cache</b></b></a></dt>
  <dd>cache is &quot;none&quot;, &quot;writeback&quot;, &quot;unsafe&quot;,
      &quot;directsync&quot; or &quot;writethrough&quot; and controls how the
      host cache is used to access block data. This is a shortcut that sets the
      <b>cache.direct</b> and <b>cache.no-flush</b> options (as in
      <b>-blockdev</b>), and additionally <b>cache.writeback</b>, which provides
      a default for the <b>write-cache</b> option of block guest devices (as in
      <b>-device</b>). The modes correspond to the following settings:
    <table class="tbl" style="border-top-style: solid;">
      <tr style="border-left-style: solid; border-bottom-style: solid;">
        <td style="border-right-style: solid;"></td>
        <td style="border-right-style: solid;">cache.writeback</td>
        <td style="border-right-style: solid;">cache.direct</td>
        <td style="border-right-style: solid;">cache.no-flush</td>
      </tr>
      <tr style="border-left-style: solid; border-bottom-style: solid;">
        <td style="border-right-style: solid;">writeback</td>
        <td style="border-right-style: solid;">on</td>
        <td style="border-right-style: solid;">off</td>
        <td style="border-right-style: solid;">off</td>
      </tr>
      <tr style="border-left-style: solid; border-bottom-style: solid;">
        <td style="border-right-style: solid;">none</td>
        <td style="border-right-style: solid;">on</td>
        <td style="border-right-style: solid;">on</td>
        <td style="border-right-style: solid;">off</td>
      </tr>
      <tr style="border-left-style: solid; border-bottom-style: solid;">
        <td style="border-right-style: solid;">writethrough</td>
        <td style="border-right-style: solid;">off</td>
        <td style="border-right-style: solid;">off</td>
        <td style="border-right-style: solid;">off</td>
      </tr>
      <tr style="border-left-style: solid; border-bottom-style: solid;">
        <td style="border-right-style: solid;">directsync</td>
        <td style="border-right-style: solid;">off</td>
        <td style="border-right-style: solid;">on</td>
        <td style="border-right-style: solid;">off</td>
      </tr>
      <tr style="border-left-style: solid; border-bottom-style: solid;">
        <td style="border-right-style: solid;">unsafe</td>
        <td style="border-right-style: solid;">on</td>
        <td style="border-right-style: solid;">off</td>
        <td style="border-right-style: solid;">on</td>
      </tr>
    </table>
    <p class="Pp">The default mode is <b>cache=writeback</b>.</p>
  </dd>
  <dt id="aio=aio"><a class="permalink" href="#aio=aio"><b><b>aio=aio</b></b></a></dt>
  <dd>aio is &quot;threads&quot;, &quot;native&quot;, or &quot;io_uring&quot;
      and selects between pthread based disk I/O, native Linux AIO, or Linux
      io_uring API.</dd>
  <dt id="format=format"><a class="permalink" href="#format=format"><b><b>format=format</b></b></a></dt>
  <dd>Specify which disk format will be used rather than detecting the format.
      Can be used to specify format=raw to avoid interpreting an untrusted
      format header.</dd>
  <dt id="werror=action,rerror=action"><a class="permalink" href="#werror=action,rerror=action"><b><b>werror=action,rerror=action</b></b></a></dt>
  <dd>Specify which action to take on write and read errors. Valid actions are:
      &quot;ignore&quot; (ignore the error and try to continue),
      &quot;stop&quot; (pause QEMU), &quot;report&quot; (report the error to the
      guest), &quot;enospc&quot; (pause QEMU only if the host disk is full;
      report the error to the guest otherwise). The default setting is
      <b>werror=enospc</b> and <b>rerror=report</b>.</dd>
  <dt id="copy"><a class="permalink" href="#copy"><b><b>copy-on-read=copy-on-read</b></b></a></dt>
  <dd>copy-on-read is &quot;on&quot; or &quot;off&quot; and enables whether to
      copy read backing file sectors into the image file.</dd>
  <dt id="bps=b,bps_rd=r,bps_wr=w"><a class="permalink" href="#bps=b,bps_rd=r,bps_wr=w"><b><b>bps=b,bps_rd=r,bps_wr=w</b></b></a></dt>
  <dd>Specify bandwidth throttling limits in bytes per second, either for all
      request types or for reads or writes only. Small values can lead to
      timeouts or hangs inside the guest. A safe minimum for disks is 2
    MB/s.</dd>
  <dt id="bps_max=bm,bps_rd_max=rm,bps_wr_max=wm"><a class="permalink" href="#bps_max=bm,bps_rd_max=rm,bps_wr_max=wm"><b><b>bps_max=bm,bps_rd_max=rm,bps_wr_max=wm</b></b></a></dt>
  <dd>Specify bursts in bytes per second, either for all request types or for
      reads or writes only. Bursts allow the guest I/O to spike above the limit
      temporarily.</dd>
  <dt id="iops=i,iops_rd=r,iops_wr=w"><a class="permalink" href="#iops=i,iops_rd=r,iops_wr=w"><b><b>iops=i,iops_rd=r,iops_wr=w</b></b></a></dt>
  <dd>Specify request rate limits in requests per second, either for all request
      types or for reads or writes only.</dd>
  <dt id="iops_max=bm,iops_rd_max=rm,iops_wr_max=wm"><a class="permalink" href="#iops_max=bm,iops_rd_max=rm,iops_wr_max=wm"><b><b>iops_max=bm,iops_rd_max=rm,iops_wr_max=wm</b></b></a></dt>
  <dd>Specify bursts in requests per second, either for all request types or for
      reads or writes only. Bursts allow the guest I/O to spike above the limit
      temporarily.</dd>
  <dt id="iops_size=is"><a class="permalink" href="#iops_size=is"><b><b>iops_size=is</b></b></a></dt>
  <dd>Let every is bytes of a request count as a new request for iops throttling
      purposes. Use this option to prevent guests from circumventing iops limits
      by sending fewer but larger requests.</dd>
  <dt id="group=g"><a class="permalink" href="#group=g"><b><b>group=g</b></b></a></dt>
  <dd>Join a throttling quota group with given name g. All drives that are
      members of the same group are accounted for together. Use this option to
      prevent guests from circumventing throttling limits by using many small
      disks instead of a single larger disk.</dd>
</dl>
</div>
<br/>
<p class="Pp">By default, the <b>cache.writeback=on</b> mode is used. It will
    report data writes as completed as soon as the data is present in the host
    page cache. This is safe as long as your guest OS makes sure to correctly
    flush disk caches where needed. If your guest OS does not handle volatile
    disk write caches correctly and your host crashes or loses power, then the
    guest may experience data corruption.</p>
<p class="Pp">For such guests, you should consider using
    <b>cache.writeback=off</b>. This means that the host page cache will be used
    to read and write data, but write notification will be sent to the guest
    only after QEMU has made sure to flush each write to the disk. Be aware that
    this has a major impact on performance.</p>
<p class="Pp">When using the <b>-snapshot</b> option, unsafe caching is always
    used.</p>
<p class="Pp">Copy-on-read avoids accessing the same backing file sectors
    repeatedly and is useful when the backing file is over a slow network. By
    default copy-on-read is off.</p>
<p class="Pp">Instead of <b>-cdrom</b> you can use:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -drive file=file,index=2,media=cdrom
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Instead of <b>-hda</b>, <b>-hdb</b>, <b>-hdc</b>, <b>-hdd</b>, you
    can use:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -drive file=file,index=0,media=disk
qemu-system-x86_64 -drive file=file,index=1,media=disk
qemu-system-x86_64 -drive file=file,index=2,media=disk
qemu-system-x86_64 -drive file=file,index=3,media=disk
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">You can open an image using pre-opened file descriptors from an fd
    set:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 \
<br/>
 -add-fd fd=3,set=2,opaque=&quot;rdwr:/path/to/file&quot; \
<br/>
 -add-fd fd=4,set=2,opaque=&quot;rdonly:/path/to/file&quot; \
<br/>
 -drive file=/dev/fdset/2,index=0,media=disk
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">You can connect a CDROM to the slave of ide0:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -drive file=file,if=ide,index=1,media=cdrom
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">If you don't specify the &quot;file=&quot; argument, you define an
    empty drive:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -drive if=ide,index=1,media=cdrom
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Instead of <b>-fda</b>, <b>-fdb</b>, you can use:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -drive file=file,index=0,if=floppy
qemu-system-x86_64 -drive file=file,index=1,if=floppy
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">By default, interface is &quot;ide&quot; and index is
    automatically incremented:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -drive file=a -drive file=b&quot;
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">is interpreted like:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -hda a -hdb b
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="mtdblock"><a class="permalink" href="#mtdblock"><b><b>-mtdblock
    file</b></b></a></dt>
  <dd>Use file as on-board Flash memory image.</dd>
  <dt id="sd"><a class="permalink" href="#sd"><b><b>-sd file</b></b></a></dt>
  <dd>Use file as SecureDigital card image.</dd>
  <dt id="pflash"><a class="permalink" href="#pflash"><b><b>-pflash
    file</b></b></a></dt>
  <dd>Use file as a parallel flash image.</dd>
  <dt id="snapshot"><a class="permalink" href="#snapshot"><b><b>-snapshot</b></b></a></dt>
  <dd>Write to temporary files instead of disk image files. In this case, the
      raw disk image you use is not written back. You can however force the
      write back by pressing C-a s (see the <i>Disk Images</i> chapter in the
      System Emulation Users Guide).</dd>
  <dt id="fsdev"><a class="permalink" href="#fsdev"><b><b>-fsdev
    local,id=id,path=path,security_model=security_model
    [,writeout=writeout][,readonly=on][,fmode=fmode][,dmode=dmode]
    [,throttling.option=value[,throttling.option=value[,...]]]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="fsdev~2"><a class="permalink" href="#fsdev~2"><b><b>-fsdev
    proxy,id=id,socket=socket[,writeout=writeout][,readonly=on]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="fsdev~3"><a class="permalink" href="#fsdev~3"><b><b>-fsdev
    proxy,id=id,sock_fd=sock_fd[,writeout=writeout][,readonly=on]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="fsdev~4"><a class="permalink" href="#fsdev~4"><b><b>-fsdev
    synth,id=id[,readonly=on]</b></b></a></dt>
  <dd>Define a new file system device. Valid options are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="local"><a class="permalink" href="#local"><b><b>local</b></b></a></dt>
  <dd>Accesses to the filesystem are done by QEMU.</dd>
  <dt id="proxy"><a class="permalink" href="#proxy"><b><b>proxy</b></b></a></dt>
  <dd>Accesses to the filesystem are done by virtfs-proxy-helper(1).</dd>
  <dt id="synth"><a class="permalink" href="#synth"><b><b>synth</b></b></a></dt>
  <dd>Synthetic filesystem, only used by QTests.</dd>
  <dt id="id=id~2"><a class="permalink" href="#id=id~2"><b><b>id=id</b></b></a></dt>
  <dd>Specifies identifier for this device.</dd>
  <dt id="path=path~2"><a class="permalink" href="#path=path~2"><b><b>path=path</b></b></a></dt>
  <dd>Specifies the export path for the file system device. Files under this
      path will be available to the 9p client on the guest.</dd>
  <dt id="security_model=security_model"><a class="permalink" href="#security_model=security_model"><b><b>security_model=security_model</b></b></a></dt>
  <dd>Specifies the security model to be used for this export path. Supported
      security models are &quot;passthrough&quot;, &quot;mapped-xattr&quot;,
      &quot;mapped-file&quot; and &quot;none&quot;. In &quot;passthrough&quot;
      security model, files are stored using the same credentials as they are
      created on the guest. This requires QEMU to run as root. In
      &quot;mapped-xattr&quot; security model, some of the file attributes like
      uid, gid, mode bits and link target are stored as file attributes. For
      &quot;mapped-file&quot; these attributes are stored in the hidden
      .virtfs_metadata directory. Directories exported by this security model
      cannot interact with other unix tools. &quot;none&quot; security model is
      same as passthrough except the sever won't report failures if it fails to
      set file attributes like ownership. Security model is mandatory only for
      local fsdriver. Other fsdrivers (like proxy) don't take security model as
      a parameter.</dd>
  <dt id="writeout=writeout"><a class="permalink" href="#writeout=writeout"><b><b>writeout=writeout</b></b></a></dt>
  <dd>This is an optional argument. The only supported value is
      &quot;immediate&quot;. This means that host page cache will be used to
      read and write data but write notification will be sent to the guest only
      when the data has been reported as written by the storage subsystem.</dd>
  <dt id="readonly=on"><a class="permalink" href="#readonly=on"><b><b>readonly=on</b></b></a></dt>
  <dd>Enables exporting 9p share as a readonly mount for guests. By default
      read-write access is given.</dd>
  <dt id="socket=socket"><a class="permalink" href="#socket=socket"><b><b>socket=socket</b></b></a></dt>
  <dd>Enables proxy filesystem driver to use passed socket file for
      communicating with virtfs-proxy-helper(1).</dd>
  <dt id="sock_fd=sock_fd"><a class="permalink" href="#sock_fd=sock_fd"><b><b>sock_fd=sock_fd</b></b></a></dt>
  <dd>Enables proxy filesystem driver to use passed socket descriptor for
      communicating with virtfs-proxy-helper(1). Usually a helper like libvirt
      will create socketpair and pass one of the fds as sock_fd.</dd>
  <dt id="fmode=fmode"><a class="permalink" href="#fmode=fmode"><b><b>fmode=fmode</b></b></a></dt>
  <dd>Specifies the default mode for newly created files on the host. Works only
      with security models &quot;mapped-xattr&quot; and
    &quot;mapped-file&quot;.</dd>
  <dt id="dmode=dmode"><a class="permalink" href="#dmode=dmode"><b><b>dmode=dmode</b></b></a></dt>
  <dd>Specifies the default mode for newly created directories on the host.
      Works only with security models &quot;mapped-xattr&quot; and
      &quot;mapped-file&quot;.</dd>
  <dt id="throttling.bps"><a class="permalink" href="#throttling.bps"><b><b>throttling.bps-total=b,throttling.bps-read=r,throttling.bps-write=w</b></b></a></dt>
  <dd>Specify bandwidth throttling limits in bytes per second, either for all
      request types or for reads or writes only.</dd>
  <dt id="throttling.bps~2"><a class="permalink" href="#throttling.bps~2"><b><b>throttling.bps-total-max=bm,bps-read-max=rm,bps-write-max=wm</b></b></a></dt>
  <dd>Specify bursts in bytes per second, either for all request types or for
      reads or writes only. Bursts allow the guest I/O to spike above the limit
      temporarily.</dd>
  <dt id="throttling.iops"><a class="permalink" href="#throttling.iops"><b><b>throttling.iops-total=i,throttling.iops-read=r,
    throttling.iops-write=w</b></b></a></dt>
  <dd>Specify request rate limits in requests per second, either for all request
      types or for reads or writes only.</dd>
  <dt id="throttling.iops~2"><a class="permalink" href="#throttling.iops~2"><b><b>throttling.iops-total-max=im,throttling.iops-read-max=irm,
    throttling.iops-write-max=iwm</b></b></a></dt>
  <dd>Specify bursts in requests per second, either for all request types or for
      reads or writes only. Bursts allow the guest I/O to spike above the limit
      temporarily.</dd>
  <dt id="throttling.iops~3"><a class="permalink" href="#throttling.iops~3"><b><b>throttling.iops-size=is</b></b></a></dt>
  <dd>Let every is bytes of a request count as a new request for iops throttling
      purposes.</dd>
</dl>
</div>
<br/>
<p class="Pp">-fsdev option is used along with -device driver
    &quot;virtio-9p-...&quot;.</p>
<dl class="Bl-tag">
  <dt id="device~10"><a class="permalink" href="#device~10"><b><b>-device
    virtio-9p-type,fsdev=id,mount_tag=mount_tag</b></b></a></dt>
  <dd>Options for virtio-9p-... driver are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="type"><a class="permalink" href="#type"><b><b>type</b></b></a></dt>
  <dd>Specifies the variant to be used. Supported values are &quot;pci&quot;,
      &quot;ccw&quot; or &quot;device&quot;, depending on the machine type.</dd>
  <dt id="fsdev=id"><a class="permalink" href="#fsdev=id"><b><b>fsdev=id</b></b></a></dt>
  <dd>Specifies the id value specified along with -fsdev option.</dd>
  <dt id="mount_tag=mount_tag"><a class="permalink" href="#mount_tag=mount_tag"><b><b>mount_tag=mount_tag</b></b></a></dt>
  <dd>Specifies the tag name to be used by the guest to mount this export
    point.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="virtfs"><a class="permalink" href="#virtfs"><b><b>-virtfs
    local,path=path,mount_tag=mount_tag
    ,security_model=security_model[,writeout=writeout][,readonly=on]
    [,fmode=fmode][,dmode=dmode][,multidevs=multidevs]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="virtfs~2"><a class="permalink" href="#virtfs~2"><b><b>-virtfs
    proxy,socket=socket,mount_tag=mount_tag
    [,writeout=writeout][,readonly=on]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="virtfs~3"><a class="permalink" href="#virtfs~3"><b><b>-virtfs
    proxy,sock_fd=sock_fd,mount_tag=mount_tag
    [,writeout=writeout][,readonly=on]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="virtfs~4"><a class="permalink" href="#virtfs~4"><b><b>-virtfs
    synth,mount_tag=mount_tag</b></b></a></dt>
  <dd>Define a new virtual filesystem device and expose it to the guest using a
      virtio-9p-device (a.k.a. 9pfs), which essentially means that a certain
      directory on host is made directly accessible by guest as a pass-through
      file system by using the 9P network protocol for communication between
      host and guests, if desired even accessible, shared by several guests
      simultaniously.
    <p class="Pp">Note that <b>-virtfs</b> is actually just a convenience
        shortcut for its generalized form <b>-fsdev -device
      virtio-9p-pci</b>.</p>
    <p class="Pp">The general form of pass-through file system options are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="local~2"><a class="permalink" href="#local~2"><b><b>local</b></b></a></dt>
  <dd>Accesses to the filesystem are done by QEMU.</dd>
  <dt id="proxy~2"><a class="permalink" href="#proxy~2"><b><b>proxy</b></b></a></dt>
  <dd>Accesses to the filesystem are done by virtfs-proxy-helper(1).</dd>
  <dt id="synth~2"><a class="permalink" href="#synth~2"><b><b>synth</b></b></a></dt>
  <dd>Synthetic filesystem, only used by QTests.</dd>
  <dt id="id=id~3"><a class="permalink" href="#id=id~3"><b><b>id=id</b></b></a></dt>
  <dd>Specifies identifier for the filesystem device</dd>
  <dt id="path=path~3"><a class="permalink" href="#path=path~3"><b><b>path=path</b></b></a></dt>
  <dd>Specifies the export path for the file system device. Files under this
      path will be available to the 9p client on the guest.</dd>
  <dt id="security_model=security_model~2"><a class="permalink" href="#security_model=security_model~2"><b><b>security_model=security_model</b></b></a></dt>
  <dd>Specifies the security model to be used for this export path. Supported
      security models are &quot;passthrough&quot;, &quot;mapped-xattr&quot;,
      &quot;mapped-file&quot; and &quot;none&quot;. In &quot;passthrough&quot;
      security model, files are stored using the same credentials as they are
      created on the guest. This requires QEMU to run as root. In
      &quot;mapped-xattr&quot; security model, some of the file attributes like
      uid, gid, mode bits and link target are stored as file attributes. For
      &quot;mapped-file&quot; these attributes are stored in the hidden
      .virtfs_metadata directory. Directories exported by this security model
      cannot interact with other unix tools. &quot;none&quot; security model is
      same as passthrough except the sever won't report failures if it fails to
      set file attributes like ownership. Security model is mandatory only for
      local fsdriver. Other fsdrivers (like proxy) don't take security model as
      a parameter.</dd>
  <dt id="writeout=writeout~2"><a class="permalink" href="#writeout=writeout~2"><b><b>writeout=writeout</b></b></a></dt>
  <dd>This is an optional argument. The only supported value is
      &quot;immediate&quot;. This means that host page cache will be used to
      read and write data but write notification will be sent to the guest only
      when the data has been reported as written by the storage subsystem.</dd>
  <dt id="readonly=on~2"><a class="permalink" href="#readonly=on~2"><b><b>readonly=on</b></b></a></dt>
  <dd>Enables exporting 9p share as a readonly mount for guests. By default
      read-write access is given.</dd>
  <dt id="socket=socket~2"><a class="permalink" href="#socket=socket~2"><b><b>socket=socket</b></b></a></dt>
  <dd>Enables proxy filesystem driver to use passed socket file for
      communicating with virtfs-proxy-helper(1). Usually a helper like libvirt
      will create socketpair and pass one of the fds as sock_fd.</dd>
  <dt id="sock_fd"><a class="permalink" href="#sock_fd"><b><b>sock_fd</b></b></a></dt>
  <dd>Enables proxy filesystem driver to use passed 'sock_fd' as the socket
      descriptor for interfacing with virtfs-proxy-helper(1).</dd>
  <dt id="fmode=fmode~2"><a class="permalink" href="#fmode=fmode~2"><b><b>fmode=fmode</b></b></a></dt>
  <dd>Specifies the default mode for newly created files on the host. Works only
      with security models &quot;mapped-xattr&quot; and
    &quot;mapped-file&quot;.</dd>
  <dt id="dmode=dmode~2"><a class="permalink" href="#dmode=dmode~2"><b><b>dmode=dmode</b></b></a></dt>
  <dd>Specifies the default mode for newly created directories on the host.
      Works only with security models &quot;mapped-xattr&quot; and
      &quot;mapped-file&quot;.</dd>
  <dt id="mount_tag=mount_tag~2"><a class="permalink" href="#mount_tag=mount_tag~2"><b><b>mount_tag=mount_tag</b></b></a></dt>
  <dd>Specifies the tag name to be used by the guest to mount this export
    point.</dd>
  <dt id="multidevs=multidevs"><a class="permalink" href="#multidevs=multidevs"><b><b>multidevs=multidevs</b></b></a></dt>
  <dd>Specifies how to deal with multiple devices being shared with a 9p export.
      Supported behaviours are either &quot;remap&quot;, &quot;forbid&quot; or
      &quot;warn&quot;. The latter is the default behaviour on which virtfs 9p
      expects only one device to be shared with the same export, and if more
      than one device is shared and accessed via the same 9p export then only a
      warning message is logged (once) by qemu on host side. In order to avoid
      file ID collisions on guest you should either create a separate virtfs
      export for each device to be shared with guests (recommended way) or you
      might use &quot;remap&quot; instead which allows you to share multiple
      devices with only one export instead, which is achieved by remapping the
      original inode numbers from host to guest in a way that would prevent such
      collisions. Remapping inodes in such use cases is required because the
      original device IDs from host are never passed and exposed on guest.
      Instead all files of an export shared with virtfs always share the same
      device id on guest. So two files with identical inode numbers but from
      actually different devices on host would otherwise cause a file ID
      collision and hence potential misbehaviours on guest. &quot;forbid&quot;
      on the other hand assumes like &quot;warn&quot; that only one device is
      shared by the same export, however it will not only log a warning message
      but also deny access to additional devices on guest. Note though that
      &quot;forbid&quot; does currently not block all possible file access
      operations (e.g. readdir() would still return entries from other
    devices).</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="iscsi"><a class="permalink" href="#iscsi"><b><b>-iscsi</b></b></a></dt>
  <dd>Configure iSCSI session parameters.</dd>
</dl>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="USB_convenience_options"><a class="permalink" href="#USB_convenience_options">USB
  convenience options</a></h2>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="usb"><a class="permalink" href="#usb"><b><b>-usb</b></b></a></dt>
  <dd>Enable USB emulation on machine types with an on-board USB host controller
      (if not enabled by default). Note that on-board USB host controllers may
      not support USB 3.0. In this case <b>-device qemu-xhci</b> can be used
      instead on machines with PCI.</dd>
  <dt id="usbdevice"><a class="permalink" href="#usbdevice"><b><b>-usbdevice
    devname</b></b></a></dt>
  <dd>Add the USB device devname, and enable an on-board USB controller if
      possible and necessary (just like it can be done via <b>-machine
      usb=on</b>). Note that this option is mainly intended for the user's
      convenience only. More fine-grained control can be achieved by selecting a
      USB host controller (if necessary) and the desired USB device via the
      <b>-device</b> option instead. For example, instead of using <b>-usbdevice
      mouse</b> it is possible to use <b>-device qemu-xhci -device usb-mouse</b>
      to connect the USB mouse to a USB 3.0 controller instead (at least on
      machines that support PCI and do not have an USB controller enabled by
      default yet). For more details, see the chapter about <i>Connecting USB
      devices</i> in the System Emulation Users Guide. Possible devices for
      devname are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="braille"><a class="permalink" href="#braille"><b><b>braille</b></b></a></dt>
  <dd>Braille device. This will use BrlAPI to display the braille output on a
      real or fake device (i.e. it also creates a corresponding <b>braille</b>
      chardev automatically beside the <b>usb-braille</b> USB device).</dd>
  <dt id="keyboard"><a class="permalink" href="#keyboard"><b><b>keyboard</b></b></a></dt>
  <dd>Standard USB keyboard. Will override the PS/2 keyboard (if present).</dd>
  <dt id="mouse"><a class="permalink" href="#mouse"><b><b>mouse</b></b></a></dt>
  <dd>Virtual Mouse. This will override the PS/2 mouse emulation when
    activated.</dd>
  <dt id="tablet"><a class="permalink" href="#tablet"><b><b>tablet</b></b></a></dt>
  <dd>Pointer device that uses absolute coordinates (like a touchscreen). This
      means QEMU is able to report the mouse position without having to grab the
      mouse. Also overrides the PS/2 mouse emulation when activated.</dd>
  <dt id="wacom"><a class="permalink" href="#wacom"><b><b>wacom-tablet</b></b></a></dt>
  <dd>Wacom PenPartner USB tablet.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Display_options"><a class="permalink" href="#Display_options">Display
  options</a></h2>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="display"><a class="permalink" href="#display"><b><b>-display
    type</b></b></a></dt>
  <dd>Select type of display to use. This option is a replacement for the old
      style -sdl/-curses/... options. Use <b>-display help</b> to list the
      available display types. Valid values for type are</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="spice"><a class="permalink" href="#spice"><b><b>spice-app[,gl=on|off]</b></b></a></dt>
  <dd>Start QEMU as a Spice server and launch the default Spice client
      application. The Spice server will redirect the serial consoles and QEMU
      monitors. (Since 4.0)</dd>
  <dt id="dbus"><a class="permalink" href="#dbus"><b><b>dbus</b></b></a></dt>
  <dd>Export the display over D-Bus interfaces. (Since 7.0)
    <p class="Pp">The connection is registered with the &quot;org.qemu&quot;
        name (and queued when already owned).</p>
    <p class="Pp"><b>addr=&lt;dbusaddr&gt;</b> : D-Bus bus address to connect
        to.</p>
    <p class="Pp"><b>p2p=yes|no</b> : Use peer-to-peer connection, accepted via
        QMP <b>add_client</b>.</p>
    <p class="Pp"><b>gl=on|off|core|es</b> : Use OpenGL for rendering (the D-Bus
        interface will share framebuffers with DMABUF file descriptors).</p>
  </dd>
  <dt id="sdl"><a class="permalink" href="#sdl"><b><b>sdl</b></b></a></dt>
  <dd>Display video output via SDL (usually in a separate graphics window; see
      the SDL documentation for other possibilities). Valid parameters are:
    <p class="Pp"><b>grab-mod=&lt;mods&gt;</b> : Used to select the modifier
        keys for toggling the mouse grabbing in conjunction with the
        &quot;g&quot; key. <b>&lt;mods&gt;</b> can be either
        <b>lshift-lctrl-lalt</b> or <b>rctrl</b>.</p>
    <p class="Pp"><b>alt_grab=on|off</b> : Use Control+Alt+Shift-g to toggle
        mouse grabbing. This parameter is deprecated - use <b>grab-mod</b>
        instead.</p>
    <p class="Pp"><b>ctrl_grab=on|off</b> : Use Right-Control-g to toggle mouse
        grabbing. This parameter is deprecated - use <b>grab-mod</b>
      instead.</p>
    <p class="Pp"><b>gl=on|off|core|es</b> : Use OpenGL for displaying</p>
    <p class="Pp"><b>show-cursor=on|off</b> : Force showing the mouse cursor</p>
    <p class="Pp"><b>window-close=on|off</b> : Allow to quit qemu with window
        close button</p>
  </dd>
  <dt id="gtk"><a class="permalink" href="#gtk"><b><b>gtk</b></b></a></dt>
  <dd>Display video output in a GTK window. This interface provides drop-down
      menus and other UI elements to configure and control the VM during
      runtime. Valid parameters are:
    <p class="Pp"><b>full-screen=on|off</b> : Start in fullscreen mode</p>
    <p class="Pp"><b>gl=on|off</b> : Use OpenGL for displaying</p>
    <p class="Pp"><b>grab-on-hover=on|off</b> : Grab keyboard input on mouse
        hover</p>
    <p class="Pp"><b>show-cursor=on|off</b> : Force showing the mouse cursor</p>
    <p class="Pp"><b>window-close=on|off</b> : Allow to quit qemu with window
        close button</p>
  </dd>
  <dt id="curses_,charset=_encoding__"><a class="permalink" href="#curses_,charset=_encoding__"><b><b>curses[,charset=&lt;encoding&gt;]</b></b></a></dt>
  <dd>Display video output via curses. For graphics device models which support
      a text mode, QEMU can display this output using a curses/ncurses
      interface. Nothing is displayed when the graphics device is in graphical
      mode or if the graphics device does not support a text mode. Generally
      only the VGA device models support text mode. The font charset used by the
      guest can be specified with the <b>charset</b> option, for example
      <b>charset=CP850</b> for IBM CP850 encoding. The default is
    <b>CP437</b>.</dd>
  <dt id="cocoa"><a class="permalink" href="#cocoa"><b><b>cocoa</b></b></a></dt>
  <dd>Display video output in a Cocoa window. Mac only. This interface provides
      drop-down menus and other UI elements to configure and control the VM
      during runtime. Valid parameters are:
    <p class="Pp"><b>show-cursor=on|off</b> : Force showing the mouse cursor</p>
    <p class="Pp"><b>left-command-key=on|off</b> : Disable forwarding left
        command key to host</p>
  </dd>
  <dt id="egl"><a class="permalink" href="#egl"><b><b>egl-headless[,rendernode=&lt;file&gt;]</b></b></a></dt>
  <dd>Offload all OpenGL operations to a local DRI device. For any graphical
      display, this display needs to be paired with either VNC or SPICE
      displays.</dd>
  <dt id="vnc=_display_"><a class="permalink" href="#vnc=_display_"><b><b>vnc=&lt;display&gt;</b></b></a></dt>
  <dd>Start a VNC server on display &lt;display&gt;</dd>
  <dt id="none"><a class="permalink" href="#none"><b><b>none</b></b></a></dt>
  <dd>Do not display video output. The guest will still see an emulated graphics
      card, but its output will not be displayed to the QEMU user. This option
      differs from the -nographic option in that it only affects what is done
      with video output; -nographic also changes the destination of the serial
      and parallel port data.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="nographic"><a class="permalink" href="#nographic"><b><b>-nographic</b></b></a></dt>
  <dd>Normally, if QEMU is compiled with graphical window support, it displays
      output such as guest graphics, guest console, and the QEMU monitor in a
      window. With this option, you can totally disable graphical output so that
      QEMU is a simple command line application. The emulated serial port is
      redirected on the console and muxed with the monitor (unless redirected
      elsewhere explicitly). Therefore, you can still use QEMU to debug a Linux
      kernel with a serial console. Use C-a h for help on switching between the
      console and monitor.</dd>
  <dt id="curses"><a class="permalink" href="#curses"><b><b>-curses</b></b></a></dt>
  <dd>Normally, if QEMU is compiled with graphical window support, it displays
      output such as guest graphics, guest console, and the QEMU monitor in a
      window. With this option, QEMU can display the VGA output when in text
      mode using a curses/ncurses interface. Nothing is displayed in graphical
      mode.</dd>
  <dt id="alt"><a class="permalink" href="#alt"><b><b>-alt-grab</b></b></a></dt>
  <dd>Use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt). Note that this
      also affects the special keys (for fullscreen, monitor-mode switching,
      etc). This option is deprecated - please use <b>-display
      sdl,grab-mod=lshift-lctrl-lalt</b> instead.</dd>
  <dt id="ctrl"><a class="permalink" href="#ctrl"><b><b>-ctrl-grab</b></b></a></dt>
  <dd>Use Right-Ctrl to grab mouse (instead of Ctrl-Alt). Note that this also
      affects the special keys (for fullscreen, monitor-mode switching, etc).
      This option is deprecated - please use <b>-display sdl,grab-mod=rctrl</b>
      instead.</dd>
  <dt id="sdl~2"><a class="permalink" href="#sdl~2"><b><b>-sdl</b></b></a></dt>
  <dd>Enable SDL.</dd>
  <dt id="spice~2"><a class="permalink" href="#spice~2"><b><b>-spice
    option[,option[,...]]</b></b></a></dt>
  <dd>Enable the spice remote desktop protocol. Valid options are</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="port=_nr_"><a class="permalink" href="#port=_nr_"><b><b>port=&lt;nr&gt;</b></b></a></dt>
  <dd>Set the TCP port spice is listening on for plaintext channels.</dd>
  <dt id="addr=_addr_"><a class="permalink" href="#addr=_addr_"><b><b>addr=&lt;addr&gt;</b></b></a></dt>
  <dd>Set the IP address spice is listening on. Default is any address.</dd>
  <dt id="ipv4=on_off"><a class="permalink" href="#ipv4=on_off"><b><b>ipv4=on|off</b>;
    <b>ipv6=on|off</b>; <b>unix=on|off</b></b></a></dt>
  <dd>Force using the specified IP version.</dd>
  <dt id="password=_string_"><a class="permalink" href="#password=_string_"><b><b>password=&lt;string&gt;</b></b></a></dt>
  <dd>Set the password you need to authenticate.
    <p class="Pp">This option is deprecated and insecure because it leaves the
        password visible in the process listing. Use <b>password-secret</b>
        instead.</p>
  </dd>
  <dt id="password"><a class="permalink" href="#password"><b><b>password-secret=&lt;secret-id&gt;</b></b></a></dt>
  <dd>Set the ID of the <b>secret</b> object containing the password you need to
      authenticate.</dd>
  <dt id="sasl=on_off"><a class="permalink" href="#sasl=on_off"><b><b>sasl=on|off</b></b></a></dt>
  <dd>Require that the client use SASL to authenticate with the spice. The exact
      choice of authentication method used is controlled from the system /
      user's SASL configuration file for the 'qemu' service. This is typically
      found in /etc/sasl2/qemu.conf. If running QEMU as an unprivileged user, an
      environment variable SASL_CONF_PATH can be used to make it search
      alternate locations for the service config. While some SASL auth methods
      can also provide data encryption (eg GSSAPI), it is recommended that SASL
      always be combined with the 'tls' and 'x509' settings to enable use of SSL
      and server certificates. This ensures a data encryption preventing
      compromise of authentication credentials.</dd>
  <dt id="disable"><a class="permalink" href="#disable"><b><b>disable-ticketing=on|off</b></b></a></dt>
  <dd>Allow client connects without authentication.</dd>
  <dt id="disable~2"><a class="permalink" href="#disable~2"><b><b>disable-copy-paste=on|off</b></b></a></dt>
  <dd>Disable copy paste between the client and the guest.</dd>
  <dt id="disable~3"><a class="permalink" href="#disable~3"><b><b>disable-agent-file-xfer=on|off</b></b></a></dt>
  <dd>Disable spice-vdagent based file-xfer between the client and the
    guest.</dd>
  <dt id="tls"><a class="permalink" href="#tls"><b><b>tls-port=&lt;nr&gt;</b></b></a></dt>
  <dd>Set the TCP port spice is listening on for encrypted channels.</dd>
  <dt id="x509"><a class="permalink" href="#x509"><b><b>x509-dir=&lt;dir&gt;</b></b></a></dt>
  <dd>Set the x509 file directory. Expects same filenames as -vnc
      $display,x509=$dir</dd>
  <dt id="x509~2"><a class="permalink" href="#x509~2"><b><b>x509-key-file=&lt;file&gt;</b>;
    <b>x509-key-password=&lt;file&gt;</b>; <b>x509-cert-file=&lt;file&gt;</b>;
    <b>x509-cacert-file=&lt;file&gt;</b>;
    <b>x509-dh-key-file=&lt;file&gt;</b></b></a></dt>
  <dd>The x509 file names can also be configured individually.</dd>
  <dt id="tls~2"><a class="permalink" href="#tls~2"><b><b>tls-ciphers=&lt;list&gt;</b></b></a></dt>
  <dd>Specify which ciphers to use.</dd>
  <dt id="tls~3"><a class="permalink" href="#tls~3"><b><b>tls-channel=[main|display|cursor|inputs|record|playback]</b>;
    <b>plaintext-channel=[main|display|cursor|inputs|record|playback]</b></b></a></dt>
  <dd>Force specific channel to be used with or without TLS encryption. The
      options can be specified multiple times to configure multiple channels.
      The special name &quot;default&quot; can be used to set the default mode.
      For channels which are not explicitly forced into one mode the spice
      client is allowed to pick tls/plaintext as he pleases.</dd>
  <dt id="image"><a class="permalink" href="#image"><b><b>image-compression=[auto_glz|auto_lz|quic|glz|lz|off]</b></b></a></dt>
  <dd>Configure image compression (lossless). Default is auto_glz.</dd>
  <dt id="jpeg"><a class="permalink" href="#jpeg"><b><b>jpeg-wan-compression=[auto|never|always]</b>;
    <b>zlib-glz-wan-compression=[auto|never|always]</b></b></a></dt>
  <dd>Configure wan image compression (lossy for slow links). Default is
    auto.</dd>
  <dt id="streaming"><a class="permalink" href="#streaming"><b><b>streaming-video=[off|all|filter]</b></b></a></dt>
  <dd>Configure video stream detection. Default is off.</dd>
  <dt id="agent"><a class="permalink" href="#agent"><b><b>agent-mouse=[on|off]</b></b></a></dt>
  <dd>Enable/disable passing mouse events via vdagent. Default is on.</dd>
  <dt id="playback"><a class="permalink" href="#playback"><b><b>playback-compression=[on|off]</b></b></a></dt>
  <dd>Enable/disable audio stream compression (using celt 0.5.1). Default is
    on.</dd>
  <dt id="seamless"><a class="permalink" href="#seamless"><b><b>seamless-migration=[on|off]</b></b></a></dt>
  <dd>Enable/disable spice seamless migration. Default is off.</dd>
  <dt id="gl=_on_off_"><a class="permalink" href="#gl=_on_off_"><b><b>gl=[on|off]</b></b></a></dt>
  <dd>Enable/disable OpenGL context. Default is off.</dd>
  <dt id="rendernode=_file_"><a class="permalink" href="#rendernode=_file_"><b><b>rendernode=&lt;file&gt;</b></b></a></dt>
  <dd>DRM render node for OpenGL rendering. If not specified, it will pick the
      first available. (Since 2.9)</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="portrait"><a class="permalink" href="#portrait"><b><b>-portrait</b></b></a></dt>
  <dd>Rotate graphical output 90 deg left (only PXA LCD).</dd>
  <dt id="rotate"><a class="permalink" href="#rotate"><b><b>-rotate
    deg</b></b></a></dt>
  <dd>Rotate graphical output some deg left (only PXA LCD).</dd>
  <dt id="vga"><a class="permalink" href="#vga"><b><b>-vga type</b></b></a></dt>
  <dd>Select type of VGA card to emulate. Valid values for type are</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="cirrus"><a class="permalink" href="#cirrus"><b><b>cirrus</b></b></a></dt>
  <dd>Cirrus Logic GD5446 Video card. All Windows versions starting from Windows
      95 should recognize and use this graphic card. For optimal performances,
      use 16 bit color depth in the guest and the host OS. (This card was the
      default before QEMU 2.2)</dd>
  <dt id="std"><a class="permalink" href="#std"><b><b>std</b></b></a></dt>
  <dd>Standard VGA card with Bochs VBE extensions. If your guest OS supports the
      VESA 2.0 VBE extensions (e.g. Windows XP) and if you want to use high
      resolution modes (&gt;= 1280x1024x16) then you should use this option.
      (This card is the default since QEMU 2.2)</dd>
  <dt id="vmware"><a class="permalink" href="#vmware"><b><b>vmware</b></b></a></dt>
  <dd>VMWare SVGA-II compatible adapter. Use it if you have sufficiently recent
      XFree86/XOrg server or Windows guest with a driver for this card.</dd>
  <dt id="qxl"><a class="permalink" href="#qxl"><b><b>qxl</b></b></a></dt>
  <dd>QXL paravirtual graphic card. It is VGA compatible (including VESA 2.0 VBE
      support). Works best with qxl guest drivers installed though. Recommended
      choice when using the spice protocol.</dd>
  <dt id="tcx"><a class="permalink" href="#tcx"><b><b>tcx</b></b></a></dt>
  <dd>(sun4m only) Sun TCX framebuffer. This is the default framebuffer for
      sun4m machines and offers both 8-bit and 24-bit colour depths at a fixed
      resolution of 1024x768.</dd>
  <dt id="cg3"><a class="permalink" href="#cg3"><b><b>cg3</b></b></a></dt>
  <dd>(sun4m only) Sun cgthree framebuffer. This is a simple 8-bit framebuffer
      for sun4m machines available in both 1024x768 (OpenBIOS) and 1152x900
      (OBP) resolutions aimed at people wishing to run older Solaris
    versions.</dd>
  <dt id="virtio"><a class="permalink" href="#virtio"><b><b>virtio</b></b></a></dt>
  <dd>Virtio VGA card.</dd>
  <dt id="none~2"><a class="permalink" href="#none~2"><b><b>none</b></b></a></dt>
  <dd>Disable VGA card.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="full"><a class="permalink" href="#full"><b><b>-full-screen</b></b></a></dt>
  <dd>Start in full screen.</dd>
  <dt id="g"><a class="permalink" href="#g"><b><b>-g</b>
    <i>width</i><b>x</b><i>height</i><b>[x</b><i>depth</i><b>]</b></b></a></dt>
  <dd>Set the initial graphical resolution and depth (PPC, SPARC only).
    <p class="Pp">For PPC the default is 800x600x32.</p>
    <p class="Pp">For SPARC with the TCX graphics device, the default is
        1024x768x8 with the option of 1024x768x24. For cgthree, the default is
        1024x768x8 with the option of 1152x900x8 for people who wish to use
      OBP.</p>
  </dd>
  <dt id="vnc"><a class="permalink" href="#vnc"><b><b>-vnc
    display[,option[,option[,...]]]</b></b></a></dt>
  <dd>Normally, if QEMU is compiled with graphical window support, it displays
      output such as guest graphics, guest console, and the QEMU monitor in a
      window. With this option, you can have QEMU listen on VNC display display
      and redirect the VGA display over the VNC session. It is very useful to
      enable the usb tablet device when using this option (option <b>-device
      usb-tablet</b>). When using the VNC display, you must use the <b>-k</b>
      parameter to set the keyboard layout if you are not using en-us. Valid
      syntax for the display is</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="to=L"><a class="permalink" href="#to=L"><b><b>to=L</b></b></a></dt>
  <dd>With this option, QEMU will try next available VNC displays, until the
      number L, if the origianlly defined &quot;-vnc display&quot; is not
      available, e.g. port 5900+display is already used by another application.
      By default, to=0.</dd>
  <dt id="host:d"><a class="permalink" href="#host:d"><b><b>host:d</b></b></a></dt>
  <dd>TCP connections will only be allowed from host on display d. By convention
      the TCP port is 5900+d. Optionally, host can be omitted in which case the
      server will accept connections from any host.</dd>
  <dt id="unix:path"><a class="permalink" href="#unix:path"><b><b>unix:path</b></b></a></dt>
  <dd>Connections will be allowed over UNIX domain sockets where path is the
      location of a unix socket to listen for connections on.</dd>
  <dt id="none~3"><a class="permalink" href="#none~3"><b><b>none</b></b></a></dt>
  <dd>VNC is initialized but not started. The monitor <b>change</b> command can
      be used to later start the VNC server.</dd>
</dl>
</div>
<br/>
<p class="Pp">Following the display value there may be one or more option flags
    separated by commas. Valid options are</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="reverse=on_off"><a class="permalink" href="#reverse=on_off"><b><b>reverse=on|off</b></b></a></dt>
  <dd>Connect to a listening VNC client via a &quot;reverse&quot; connection.
      The client is specified by the display. For reverse network connections
      (host:d,``reverse``), the d argument is a TCP port number, not a display
      number.</dd>
  <dt id="websocket=on_off"><a class="permalink" href="#websocket=on_off"><b><b>websocket=on|off</b></b></a></dt>
  <dd>Opens an additional TCP listening port dedicated to VNC Websocket
      connections. If a bare websocket option is given, the Websocket port is
      5700+display. An alternative port can be specified with the syntax
      <b>websocket</b>=port.
    <p class="Pp">If host is specified connections will only be allowed from
        this host. It is possible to control the websocket listen address
        independently, using the syntax <b>websocket</b>=host:port.</p>
    <p class="Pp">If no TLS credentials are provided, the websocket connection
        runs in unencrypted mode. If TLS credentials are provided, the websocket
        connection requires encrypted client connections.</p>
  </dd>
  <dt id="password=on_off"><a class="permalink" href="#password=on_off"><b><b>password=on|off</b></b></a></dt>
  <dd>Require that password based authentication is used for client connections.
    <p class="Pp">The password must be set separately using the
        <b>set_password</b> command in the <i>QEMU Monitor</i>. The syntax to
        change your password is: <b>set_password &lt;protocol&gt;
        &lt;password&gt;</b> where &lt;protocol&gt; could be either
        &quot;vnc&quot; or &quot;spice&quot;.</p>
    <p class="Pp">If you would like to change &lt;protocol&gt; password
        expiration, you should use <b>expire_password &lt;protocol&gt;
        &lt;expiration-time&gt;</b> where expiration time could be one of the
        following options: now, never, +seconds or UNIX time of expiration, e.g.
        +60 to make password expire in 60 seconds, or 1335196800 to make
        password expire on &quot;Mon Apr 23 12:00:00 EDT 2012&quot; (UNIX time
        for this date and time).</p>
    <p class="Pp">You can also use keywords &quot;now&quot; or &quot;never&quot;
        for the expiration time to allow &lt;protocol&gt; password to expire
        immediately or never expire.</p>
  </dd>
  <dt id="password~2"><a class="permalink" href="#password~2"><b><b>password-secret=&lt;secret-id&gt;</b></b></a></dt>
  <dd>Require that password based authentication is used for client connections,
      using the password provided by the <b>secret</b> object identified by
      <b>secret-id</b>.</dd>
  <dt id="tls~4"><a class="permalink" href="#tls~4"><b><b>tls-creds=ID</b></b></a></dt>
  <dd>Provides the ID of a set of TLS credentials to use to secure the VNC
      server. They will apply to both the normal VNC server socket and the
      websocket socket (if enabled). Setting TLS credentials will cause the VNC
      server socket to enable the VeNCrypt auth mechanism. The credentials
      should have been previously created using the <b>-object tls-creds</b>
      argument.</dd>
  <dt id="tls~5"><a class="permalink" href="#tls~5"><b><b>tls-authz=ID</b></b></a></dt>
  <dd>Provides the ID of the QAuthZ authorization object against which the
      client's x509 distinguished name will validated. This object is only
      resolved at time of use, so can be deleted and recreated on the fly while
      the VNC server is active. If missing, it will default to denying
    access.</dd>
  <dt id="sasl=on_off~2"><a class="permalink" href="#sasl=on_off~2"><b><b>sasl=on|off</b></b></a></dt>
  <dd>Require that the client use SASL to authenticate with the VNC server. The
      exact choice of authentication method used is controlled from the system /
      user's SASL configuration file for the 'qemu' service. This is typically
      found in /etc/sasl2/qemu.conf. If running QEMU as an unprivileged user, an
      environment variable SASL_CONF_PATH can be used to make it search
      alternate locations for the service config. While some SASL auth methods
      can also provide data encryption (eg GSSAPI), it is recommended that SASL
      always be combined with the 'tls' and 'x509' settings to enable use of SSL
      and server certificates. This ensures a data encryption preventing
      compromise of authentication credentials. See the <i>VNC security</i>
      section in the System Emulation Users Guide for details on using SASL
      authentication.</dd>
  <dt id="sasl"><a class="permalink" href="#sasl"><b><b>sasl-authz=ID</b></b></a></dt>
  <dd>Provides the ID of the QAuthZ authorization object against which the
      client's SASL username will validated. This object is only resolved at
      time of use, so can be deleted and recreated on the fly while the VNC
      server is active. If missing, it will default to denying access.</dd>
  <dt id="acl=on_off"><a class="permalink" href="#acl=on_off"><b><b>acl=on|off</b></b></a></dt>
  <dd>Legacy method for enabling authorization of clients against the x509
      distinguished name and SASL username. It results in the creation of two
      <b>authz-list</b> objects with IDs of <b>vnc.username</b> and
      <b>vnc.x509dname</b>. The rules for these objects must be configured with
      the HMP ACL commands.
    <p class="Pp">This option is deprecated and should no longer be used. The
        new <b>sasl-authz</b> and <b>tls-authz</b> options are a
      replacement.</p>
  </dd>
  <dt id="lossy=on_off"><a class="permalink" href="#lossy=on_off"><b><b>lossy=on|off</b></b></a></dt>
  <dd>Enable lossy compression methods (gradient, JPEG, ...). If this option is
      set, VNC client may receive lossy framebuffer updates depending on its
      encoding settings. Enabling this option can save a lot of bandwidth at the
      expense of quality.</dd>
  <dt id="non"><a class="permalink" href="#non"><b><b>non-adaptive=on|off</b></b></a></dt>
  <dd>Disable adaptive encodings. Adaptive encodings are enabled by default. An
      adaptive encoding will try to detect frequently updated screen regions,
      and send updates in these regions using a lossy encoding (like JPEG). This
      can be really helpful to save bandwidth when playing videos. Disabling
      adaptive encodings restores the original static behavior of encodings like
      Tight.</dd>
  <dt id="share=_allow"><a class="permalink" href="#share=_allow"><b><b>share=[allow-exclusive|force-shared|ignore]</b></b></a></dt>
  <dd>Set display sharing policy. 'allow-exclusive' allows clients to ask for
      exclusive access. As suggested by the rfb spec this is implemented by
      dropping other connections. Connecting multiple clients in parallel
      requires all clients asking for a shared session (vncviewer: -shared
      switch). This is the default. 'force-shared' disables exclusive client
      access. Useful for shared desktop sessions, where you don't want someone
      forgetting specify -shared disconnect everybody else. 'ignore' completely
      ignores the shared flag and allows everybody connect unconditionally.
      Doesn't conform to the rfb spec but is traditional QEMU behavior.</dd>
  <dt id="key"><a class="permalink" href="#key"><b><b>key-delay-ms</b></b></a></dt>
  <dd>Set keyboard delay, for key down and key up events, in milliseconds.
      Default is 10. Keyboards are low-bandwidth devices, so this slowdown can
      help the device and guest to keep up and not lose events in case events
      are arriving in bulk. Possible causes for the latter are flaky network
      connections, or scripts for automated testing.</dd>
  <dt id="audiodev=audiodev"><a class="permalink" href="#audiodev=audiodev"><b><b>audiodev=audiodev</b></b></a></dt>
  <dd>Use the specified audiodev when the VNC client requests audio
      transmission. When not using an -audiodev argument, this option must be
      omitted, otherwise is must be present and specify a valid audiodev.</dd>
  <dt id="power"><a class="permalink" href="#power"><b><b>power-control=on|off</b></b></a></dt>
  <dd>Permit the remote client to issue shutdown, reboot or reset power control
      requests.</dd>
</dl>
</div>
<br/>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="i386_target_only"><a class="permalink" href="#i386_target_only">i386
  target only</a></h2>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="win2k"><a class="permalink" href="#win2k"><b><b>-win2k-hack</b></b></a></dt>
  <dd>Use it when installing Windows 2000 to avoid a disk full bug. After
      Windows 2000 is installed, you no longer need this option (this option
      slows down the IDE transfers).</dd>
  <dt id="no"><a class="permalink" href="#no"><b><b>-no-fd-bootchk</b></b></a></dt>
  <dd>Disable boot signature checking for floppy disks in BIOS. May be needed to
      boot from old floppy disks.</dd>
  <dt id="no~2"><a class="permalink" href="#no~2"><b><b>-no-acpi</b></b></a></dt>
  <dd>Disable ACPI (Advanced Configuration and Power Interface) support. Use it
      if your guest OS complains about ACPI problems (PC target machine
    only).</dd>
  <dt id="no~3"><a class="permalink" href="#no~3"><b><b>-no-hpet</b></b></a></dt>
  <dd>Disable HPET support.</dd>
  <dt id="acpitable"><a class="permalink" href="#acpitable"><b><b>-acpitable
    [sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n]
    [,asl_compiler_id=str][,asl_compiler_rev=n][,data=file1[:file2]...]</b></b></a></dt>
  <dd>Add ACPI table with specified header fields and context from specified
      files. For file=, take whole ACPI table from the specified files,
      including all ACPI headers (possible overridden by other options). For
      data=, only data portion of the table is used, all header information is
      specified in the command line. If a SLIC table is supplied to QEMU, then
      the SLIC's oem_id and oem_table_id fields will override the same in the
      RSDT and the FADT (a.k.a. FACP), in order to ensure the field matches
      required by the Microsoft SLIC spec and the ACPI spec.</dd>
  <dt id="smbios"><a class="permalink" href="#smbios"><b><b>-smbios
    file=binary</b></b></a></dt>
  <dd>Load SMBIOS entry from binary file.</dd>
  <dt id="smbios~2"><a class="permalink" href="#smbios~2"><b><b>-smbios
    type=0[,vendor=str][,version=str][,date=str][,release=%d.%d][,uefi=on|off]</b></b></a></dt>
  <dd>Specify SMBIOS type 0 fields</dd>
  <dt id="smbios~3"><a class="permalink" href="#smbios~3"><b><b>-smbios
    type=1[,manufacturer=str][,product=str][,version=str][,serial=str][,uuid=uuid][,sku=str][,family=str]</b></b></a></dt>
  <dd>Specify SMBIOS type 1 fields</dd>
  <dt id="smbios~4"><a class="permalink" href="#smbios~4"><b><b>-smbios
    type=2[,manufacturer=str][,product=str][,version=str][,serial=str][,asset=str][,location=str]</b></b></a></dt>
  <dd>Specify SMBIOS type 2 fields</dd>
  <dt id="smbios~5"><a class="permalink" href="#smbios~5"><b><b>-smbios
    type=3[,manufacturer=str][,version=str][,serial=str][,asset=str][,sku=str]</b></b></a></dt>
  <dd>Specify SMBIOS type 3 fields</dd>
  <dt id="smbios~6"><a class="permalink" href="#smbios~6"><b><b>-smbios
    type=4[,sock_pfx=str][,manufacturer=str][,version=str][,serial=str][,asset=str][,part=str][,processor-id=%d]</b></b></a></dt>
  <dd>Specify SMBIOS type 4 fields</dd>
  <dt id="smbios~7"><a class="permalink" href="#smbios~7"><b><b>-smbios
    type=11[,value=str][,path=filename]</b></b></a></dt>
  <dd>Specify SMBIOS type 11 fields
    <p class="Pp">This argument can be repeated multiple times, and values are
        added in the order they are parsed. Applications intending to use OEM
        strings data are encouraged to use their application name as a prefix
        for the value string. This facilitates passing information for multiple
        applications concurrently.</p>
    <p class="Pp">The <b>value=str</b> syntax provides the string data inline,
        while the <b>path=filename</b> syntax loads data from a file on disk.
        Note that the file is not permitted to contain any NUL bytes.</p>
    <p class="Pp">Both the <b>value</b> and <b>path</b> options can be repeated
        multiple times and will be added to the SMBIOS table in the order in
        which they appear.</p>
    <p class="Pp">Note that on the x86 architecture, the total size of all
        SMBIOS tables is limited to 65535 bytes. Thus the OEM strings data is
        not suitable for passing large amounts of data into the guest. Instead
        it should be used as a indicator to inform the guest where to locate the
        real data set, for example, by specifying the serial ID of a block
        device.</p>
    <p class="Pp">An example passing three strings is</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-smbios type=11,value=cloud-init:ds=nocloud-net;s=http://10.10.0.1:8000/,\
<br/>
                value=anaconda:method=http://dl.fedoraproject.org/pub/fedora/linux/releases/25/x86_64/os,\
<br/>
                path=/some/file/with/oemstringsdata.txt
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">In the guest OS this is visible with the <b>dmidecode</b>
  command</p>
<div class="Bd-indent">
<div class="Bd-indent">
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>$ dmidecode -t 11
Handle 0x0E00, DMI type 11, 5 bytes
OEM Strings
<br/>
     String 1: cloud-init:ds=nocloud-net;s=http://10.10.0.1:8000/
<br/>
     String 2: anaconda:method=http://dl.fedoraproject.org/pub/fedora/linux/releases/25/x86_64/os
<br/>
     String 3: myapp:some extra data
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="smbios~8"><a class="permalink" href="#smbios~8"><b><b>-smbios
    type=17[,loc_pfx=str][,bank=str][,manufacturer=str][,serial=str][,asset=str][,part=str][,speed=%d]</b></b></a></dt>
  <dd>Specify SMBIOS type 17 fields</dd>
  <dt id="smbios~9"><a class="permalink" href="#smbios~9"><b><b>-smbios
    type=41[,designation=str][,kind=str][,instance=%d][,pcidev=str]</b></b></a></dt>
  <dd>Specify SMBIOS type 41 fields
    <p class="Pp">This argument can be repeated multiple times. Its main use is
        to allow network interfaces be created as <b>enoX</b> on Linux, with X
        being the instance number, instead of the name depending on the
        interface position on the PCI bus.</p>
    <p class="Pp">Here is an example of use:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-netdev user,id=internet \
-device virtio-net-pci,mac=50:54:00:00:00:42,netdev=internet,id=internet-dev \
-smbios type=41,designation='Onboard LAN',instance=1,kind=ethernet,pcidev=internet-dev
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">In the guest OS, the device should then appear as <b>eno1</b>:</p>
<p class="Pp">..parsed-literal:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>$ ip -brief l
lo               UNKNOWN        00:00:00:00:00:00 &lt;LOOPBACK,UP,LOWER_UP&gt;
eno1             UP             50:54:00:00:00:42 &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Currently, the PCI device has to be attached to the root bus.</p>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Network_options"><a class="permalink" href="#Network_options">Network
  options</a></h2>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="nic"><a class="permalink" href="#nic"><b><b>-nic
    [tap|bridge|user|l2tpv3|vde|netmap|vhost-user|socket][,...][,mac=macaddr][,model=mn]</b></b></a></dt>
  <dd>This option is a shortcut for configuring both the on-board (default)
      guest NIC hardware and the host network backend in one go. The host
      backend options are the same as with the corresponding <b>-netdev</b>
      options below. The guest NIC model can be set with <b>model=modelname</b>.
      Use <b>model=help</b> to list the available device types. The hardware MAC
      address can be set with <b>mac=macaddr</b>.
    <p class="Pp">The following two example do exactly the same, to show how
        <b>-nic</b> can be used to shorten the command line length:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -netdev user,id=n1,ipv6=off -device e1000,netdev=n1,mac=52:54:98:76:54:32
qemu-system-x86_64 -nic user,ipv6=off,model=e1000,mac=52:54:98:76:54:32
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="nic~2"><a class="permalink" href="#nic~2"><b><b>-nic
    none</b></b></a></dt>
  <dd>Indicate that no network devices should be configured. It is used to
      override the default configuration (default NIC with &quot;user&quot; host
      network backend) which is activated if no other networking options are
      provided.</dd>
  <dt id="netdev"><a class="permalink" href="#netdev"><b><b>-netdev
    user,id=id[,option][,option][,...]</b></b></a></dt>
  <dd>Configure user mode host network backend which requires no administrator
      privilege to run. Valid options are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="id=id~4"><a class="permalink" href="#id=id~4"><b><b>id=id</b></b></a></dt>
  <dd>Assign symbolic name for use in monitor commands.</dd>
  <dt id="ipv4=on_off~2"><a class="permalink" href="#ipv4=on_off~2"><b><b>ipv4=on|off
    and ipv6=on|off</b></b></a></dt>
  <dd>Specify that either IPv4 or IPv6 must be enabled. If neither is specified
      both protocols are enabled.</dd>
  <dt id="net=addr_/mask_"><a class="permalink" href="#net=addr_/mask_"><b><b>net=addr[/mask]</b></b></a></dt>
  <dd>Set IP network address the guest will see. Optionally specify the netmask,
      either in the form a.b.c.d or as number of valid top-most bits. Default is
      10.0.2.0/24.</dd>
  <dt id="host=addr"><a class="permalink" href="#host=addr"><b><b>host=addr</b></b></a></dt>
  <dd>Specify the guest-visible address of the host. Default is the 2nd IP in
      the guest network, i.e. x.x.x.2.</dd>
  <dt id="ipv6"><a class="permalink" href="#ipv6"><b><b>ipv6-net=addr[/int]</b></b></a></dt>
  <dd>Set IPv6 network address the guest will see (default is fec0::/64). The
      network prefix is given in the usual hexadecimal IPv6 address notation.
      The prefix size is optional, and is given as the number of valid top-most
      bits (default is 64).</dd>
  <dt id="ipv6~2"><a class="permalink" href="#ipv6~2"><b><b>ipv6-host=addr</b></b></a></dt>
  <dd>Specify the guest-visible IPv6 address of the host. Default is the 2nd
      IPv6 in the guest network, i.e. xxxx::2.</dd>
  <dt id="restrict=on_off"><a class="permalink" href="#restrict=on_off"><b><b>restrict=on|off</b></b></a></dt>
  <dd>If this option is enabled, the guest will be isolated, i.e. it will not be
      able to contact the host and no guest IP packets will be routed over the
      host to the outside. This option does not affect any explicitly set
      forwarding rules.</dd>
  <dt id="hostname=name"><a class="permalink" href="#hostname=name"><b><b>hostname=name</b></b></a></dt>
  <dd>Specifies the client hostname reported by the built-in DHCP server.</dd>
  <dt id="dhcpstart=addr"><a class="permalink" href="#dhcpstart=addr"><b><b>dhcpstart=addr</b></b></a></dt>
  <dd>Specify the first of the 16 IPs the built-in DHCP server can assign.
      Default is the 15th to 31st IP in the guest network, i.e. x.x.x.15 to
      x.x.x.31.</dd>
  <dt id="dns=addr"><a class="permalink" href="#dns=addr"><b><b>dns=addr</b></b></a></dt>
  <dd>Specify the guest-visible address of the virtual nameserver. The address
      must be different from the host address. Default is the 3rd IP in the
      guest network, i.e. x.x.x.3.</dd>
  <dt id="ipv6~3"><a class="permalink" href="#ipv6~3"><b><b>ipv6-dns=addr</b></b></a></dt>
  <dd>Specify the guest-visible address of the IPv6 virtual nameserver. The
      address must be different from the host address. Default is the 3rd IP in
      the guest network, i.e. xxxx::3.</dd>
  <dt id="dnssearch=domain"><a class="permalink" href="#dnssearch=domain"><b><b>dnssearch=domain</b></b></a></dt>
  <dd>Provides an entry for the domain-search list sent by the built-in DHCP
      server. More than one domain suffix can be transmitted by specifying this
      option multiple times. If supported, this will cause the guest to
      automatically try to append the given domain suffix(es) in case a domain
      name can not be resolved.
    <p class="Pp">Example:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -nic user,dnssearch=mgmt.example.org,dnssearch=example.org
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="domainname=domain"><a class="permalink" href="#domainname=domain"><b><b>domainname=domain</b></b></a></dt>
  <dd>Specifies the client domain name reported by the built-in DHCP
    server.</dd>
  <dt id="tftp=dir"><a class="permalink" href="#tftp=dir"><b><b>tftp=dir</b></b></a></dt>
  <dd>When using the user mode network stack, activate a built-in TFTP server.
      The files in dir will be exposed as the root of a TFTP server. The TFTP
      client on the guest must be configured in binary mode (use the command
      <b>bin</b> of the Unix TFTP client).</dd>
  <dt id="tftp"><a class="permalink" href="#tftp"><b><b>tftp-server-name=name</b></b></a></dt>
  <dd>In BOOTP reply, broadcast name as the &quot;TFTP server name&quot;
      (RFC2132 option 66). This can be used to advise the guest to load boot
      files or configurations from a different server than the host
    address.</dd>
  <dt id="bootfile=file"><a class="permalink" href="#bootfile=file"><b><b>bootfile=file</b></b></a></dt>
  <dd>When using the user mode network stack, broadcast file as the BOOTP
      filename. In conjunction with <b>tftp</b>, this can be used to network
      boot a guest from a local directory.
    <p class="Pp">Example (using pxelinux):</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -hda linux.img -boot n -device e1000,netdev=n1 \
<br/>
    -netdev user,id=n1,tftp=/path/to/tftp/files,bootfile=/pxelinux.0
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="smb=dir_,smbserver=addr_"><a class="permalink" href="#smb=dir_,smbserver=addr_"><b><b>smb=dir[,smbserver=addr]</b></b></a></dt>
  <dd>When using the user mode network stack, activate a built-in SMB server so
      that Windows OSes can access to the host files in <b>dir</b>
      transparently. The IP address of the SMB server can be set to addr. By
      default the 4th IP in the guest network is used, i.e. x.x.x.4.
    <p class="Pp">In the guest Windows OS, the line:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>10.0.2.4 smbserver
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">must be added in the file <b>C:\WINDOWS\LMHOSTS</b> (for windows
    9x/Me) or <b>C:\WINNT\SYSTEM32\DRIVERS\ETC\LMHOSTS</b> (Windows
  NT/2000).</p>
<p class="Pp">Then <b>dir</b> can be accessed in <b>\\smbserver\qemu</b>.</p>
<p class="Pp">Note that a SAMBA server must be installed on the host OS.</p>
<dl class="Bl-tag">
  <dt id="hostfwd=_tcp_udp_:_hostaddr_:hostport"><a class="permalink" href="#hostfwd=_tcp_udp_:_hostaddr_:hostport"><b><b>hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport</b></b></a></dt>
  <dd>Redirect incoming TCP or UDP connections to the host port hostport to the
      guest IP address guestaddr on guest port guestport. If guestaddr is not
      specified, its value is x.x.x.15 (default first address given by the
      built-in DHCP server). By specifying hostaddr, the rule can be bound to a
      specific host interface. If no connection type is set, TCP is used. This
      option can be given multiple times.
    <p class="Pp">For example, to redirect host X11 connection from screen 1 to
        guest screen 0, use the following:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># on the host
qemu-system-x86_64 -nic user,hostfwd=tcp:127.0.0.1:6001-:6000
# this host xterm should open in the guest X11 server
xterm -display :1
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">To redirect telnet connections from host port 5555 to telnet port
    on the guest, use the following:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># on the host
qemu-system-x86_64 -nic user,hostfwd=tcp::5555-:23
telnet localhost 5555
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Then when you use on the host <b>telnet localhost 5555</b>, you
    connect to the guest telnet server.</p>
<dl class="Bl-tag">
  <dt id="guestfwd=_tcp_:server:port"><a class="permalink" href="#guestfwd=_tcp_:server:port"><b><b>guestfwd=[tcp]:server:port-dev</b>;
    <b>guestfwd=[tcp]:server:port-cmd:command</b></b></a></dt>
  <dd>Forward guest TCP connections to the IP address server on port port to the
      character device dev or to a program executed by cmd:command which gets
      spawned for each connection. This option can be given multiple times.
    <p class="Pp">You can either use a chardev directly and have that one used
        throughout QEMU's lifetime, like in the following example:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># open 10.10.1.1:4321 on bootup, connect 10.0.2.100:1234 to it whenever
# the guest accesses it
qemu-system-x86_64 -nic user,guestfwd=tcp:10.0.2.100:1234-<i>tcp:10.10.1.1:4321</i>
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Or you can execute a command on every TCP connection established
    by the guest, so that QEMU behaves similar to an inetd process for that
    virtual server:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># call &quot;netcat 10.10.1.1 4321&quot; on every TCP connection to 10.0.2.100:1234
# and connect the TCP stream to its stdin/stdout
qemu-system-x86_64 -nic  'user,id=n1,guestfwd=tcp:10.0.2.100:1234-cmd:netcat 10.10.1.1 4321'
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="netdev~2"><a class="permalink" href="#netdev~2"><b><b>-netdev
    tap,id=id[,fd=h][,ifname=name][,script=file][,downscript=dfile][,br=bridge][,helper=helper]</b></b></a></dt>
  <dd>Configure a host TAP network backend with ID id.
    <p class="Pp">Use the network script file to configure it and the network
        script dfile to deconfigure it. If name is not provided, the OS
        automatically provides one. The default network configure script is
        <b>/etc/qemu-ifup</b> and the default network deconfigure script is
        <b>/etc/qemu-ifdown</b>. Use <b>script=no</b> or <b>downscript=no</b> to
        disable script execution.</p>
    <p class="Pp">If running QEMU as an unprivileged user, use the network
        helper to configure the TAP interface and attach it to the bridge. The
        default network helper executable is <b>/path/to/qemu-bridge-helper</b>
        and the default bridge device is <b>br0</b>.</p>
    <p class="Pp"><b>fd</b>=h can be used to specify the handle of an already
        opened host TAP interface.</p>
    <p class="Pp">Examples:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>#launch a QEMU instance with the default network script
qemu-system-x86_64 linux.img -nic tap
</pre>
</div>
<br/>
</div>
<br/>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>#launch a QEMU instance with two NICs, each one connected
#to a TAP device
qemu-system-x86_64 linux.img \
<br/>
        -netdev tap,id=nd0,ifname=tap0 -device e1000,netdev=nd0 \
<br/>
        -netdev tap,id=nd1,ifname=tap1 -device rtl8139,netdev=nd1
</pre>
</div>
<br/>
</div>
<br/>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>#launch a QEMU instance with the default network helper to
#connect a TAP device to bridge br0
qemu-system-x86_64 linux.img -device virtio-net-pci,netdev=n1 \
<br/>
        -netdev tap,id=n1,&quot;helper=/path/to/qemu-bridge-helper&quot;
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="netdev~3"><a class="permalink" href="#netdev~3"><b><b>-netdev
    bridge,id=id[,br=bridge][,helper=helper]</b></b></a></dt>
  <dd>Connect a host TAP network interface to a host bridge device.
    <p class="Pp">Use the network helper helper to configure the TAP interface
        and attach it to the bridge. The default network helper executable is
        <b>/path/to/qemu-bridge-helper</b> and the default bridge device is
        <b>br0</b>.</p>
    <p class="Pp">Examples:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>#launch a QEMU instance with the default network helper to
#connect a TAP device to bridge br0
qemu-system-x86_64 linux.img -netdev bridge,id=n1 -device virtio-net,netdev=n1
</pre>
</div>
<br/>
</div>
<br/>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>#launch a QEMU instance with the default network helper to
#connect a TAP device to bridge qemubr0
qemu-system-x86_64 linux.img -netdev bridge,br=qemubr0,id=n1 -device virtio-net,netdev=n1
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="netdev~4"><a class="permalink" href="#netdev~4"><b><b>-netdev
    socket,id=id[,fd=h][,listen=[host]:port][,connect=host:port]</b></b></a></dt>
  <dd>This host network backend can be used to connect the guest's network to
      another QEMU virtual machine using a TCP socket connection. If
      <b>listen</b> is specified, QEMU waits for incoming connections on port
      (host is optional). <b>connect</b> is used to connect to another QEMU
      instance using the <b>listen</b> option. <b>fd</b>=h specifies an already
      opened TCP socket.
    <p class="Pp">Example:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># launch a first QEMU instance
qemu-system-x86_64 linux.img \
<br/>
                 -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
<br/>
                 -netdev socket,id=n1,listen=:1234
# connect the network of this instance to the network of the first instance
qemu-system-x86_64 linux.img \
<br/>
                 -device e1000,netdev=n2,mac=52:54:00:12:34:57 \
<br/>
                 -netdev socket,id=n2,connect=127.0.0.1:1234
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="netdev~5"><a class="permalink" href="#netdev~5"><b><b>-netdev
    socket,id=id[,fd=h][,mcast=maddr:port[,localaddr=addr]]</b></b></a></dt>
  <dd>Configure a socket host network backend to share the guest's network
      traffic with another QEMU virtual machines using a UDP multicast socket,
      effectively making a bus for every QEMU with same multicast address maddr
      and port. NOTES:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Several QEMU can be running on different hosts and share same bus
      (assuming correct multicast setup for these hosts).</dd>
  <dt>2.</dt>
  <dd>mcast support is compatible with User Mode Linux (argument
      <b>ethN=mcast</b>), see <i>http://user-mode-linux.sf.net</i>.</dd>
  <dt>3.</dt>
  <dd>Use <b>fd=h</b> to specify an already opened UDP multicast socket.</dd>
</dl>
</div>
<br/>
<p class="Pp">Example:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># launch one QEMU instance
qemu-system-x86_64 linux.img \
<br/>
                 -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
<br/>
                 -netdev socket,id=n1,mcast=230.0.0.1:1234
# launch another QEMU instance on same &quot;bus&quot;
qemu-system-x86_64 linux.img \
<br/>
                 -device e1000,netdev=n2,mac=52:54:00:12:34:57 \
<br/>
                 -netdev socket,id=n2,mcast=230.0.0.1:1234
# launch yet another QEMU instance on same &quot;bus&quot;
qemu-system-x86_64 linux.img \
<br/>
                 -device e1000,netdev=n3,mac=52:54:00:12:34:58 \
<br/>
                 -netdev socket,id=n3,mcast=230.0.0.1:1234
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example (User Mode Linux compat.):</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># launch QEMU instance (note mcast address selected is UML's default)
qemu-system-x86_64 linux.img \
<br/>
                 -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
<br/>
                 -netdev socket,id=n1,mcast=239.192.168.1:1102
# launch UML
/path/to/linux ubd0=/path/to/root_fs eth0=mcast
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example (send packets from host's 1.2.3.4):</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 linux.img \
<br/>
                 -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
<br/>
                 -netdev socket,id=n1,mcast=239.192.168.1:1102,localaddr=1.2.3.4
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="netdev~6"><a class="permalink" href="#netdev~6"><b><b>-netdev
    l2tpv3,id=id,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport],txsession=txsession[,rxsession=rxsession][,ipv6=on|off][,udp=on|off][,cookie64][,counter][,pincounter][,txcookie=txcookie][,rxcookie=rxcookie][,offset=offset]</b></b></a></dt>
  <dd>Configure a L2TPv3 pseudowire host network backend. L2TPv3 (RFC3931) is a
      popular protocol to transport Ethernet (and other Layer 2) data frames
      between two systems. It is present in routers, firewalls and the Linux
      kernel (from version 3.3 onwards).
    <p class="Pp">This transport allows a VM to communicate to another VM,
        router or firewall directly.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="src=srcaddr"><a class="permalink" href="#src=srcaddr"><b><b>src=srcaddr</b></b></a></dt>
  <dd>source address (mandatory)</dd>
  <dt id="dst=dstaddr"><a class="permalink" href="#dst=dstaddr"><b><b>dst=dstaddr</b></b></a></dt>
  <dd>destination address (mandatory)</dd>
  <dt id="udp"><a class="permalink" href="#udp"><b><b>udp</b></b></a></dt>
  <dd>select udp encapsulation (default is ip).</dd>
  <dt id="srcport=srcport"><a class="permalink" href="#srcport=srcport"><b><b>srcport=srcport</b></b></a></dt>
  <dd>source udp port.</dd>
  <dt id="dstport=dstport"><a class="permalink" href="#dstport=dstport"><b><b>dstport=dstport</b></b></a></dt>
  <dd>destination udp port.</dd>
  <dt id="ipv6~4"><a class="permalink" href="#ipv6~4"><b><b>ipv6</b></b></a></dt>
  <dd>force v6, otherwise defaults to v4.</dd>
  <dt id="rxcookie=rxcookie"><a class="permalink" href="#rxcookie=rxcookie"><b><b>rxcookie=rxcookie</b>;
    <b>txcookie=txcookie</b></b></a></dt>
  <dd>Cookies are a weak form of security in the l2tpv3 specification. Their
      function is mostly to prevent misconfiguration. By default they are 32
      bit.</dd>
  <dt id="cookie64"><a class="permalink" href="#cookie64"><b><b>cookie64</b></b></a></dt>
  <dd>Set cookie size to 64 bit instead of the default 32</dd>
  <dt id="counter=off"><a class="permalink" href="#counter=off"><b><b>counter=off</b></b></a></dt>
  <dd>Force a 'cut-down' L2TPv3 with no counter as in
      draft-mkonstan-l2tpext-keyed-ipv6-tunnel-00</dd>
  <dt id="pincounter=on"><a class="permalink" href="#pincounter=on"><b><b>pincounter=on</b></b></a></dt>
  <dd>Work around broken counter handling in peer. This may also help on
      networks which have packet reorder.</dd>
  <dt id="offset=offset"><a class="permalink" href="#offset=offset"><b><b>offset=offset</b></b></a></dt>
  <dd>Add an extra offset between header and data</dd>
</dl>
</div>
<br/>
<p class="Pp">For example, to attach a VM running on host 4.3.2.1 via L2TPv3 to
    the bridge br-lan on the remote Linux host 1.2.3.4:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># Setup tunnel on linux host using raw ip as encapsulation
# on 1.2.3.4
ip l2tp add tunnel remote 4.3.2.1 local 1.2.3.4 tunnel_id 1 peer_tunnel_id 1 \
<br/>
    encap udp udp_sport 16384 udp_dport 16384
ip l2tp add session tunnel_id 1 name vmtunnel0 session_id \
<br/>
    0xFFFFFFFF peer_session_id 0xFFFFFFFF
ifconfig vmtunnel0 mtu 1500
ifconfig vmtunnel0 up
brctl addif br-lan vmtunnel0
# on 4.3.2.1
# launch QEMU instance - if your network has reorder or is very lossy add ,pincounter
qemu-system-x86_64 linux.img -device e1000,netdev=n1 \
<br/>
    -netdev l2tpv3,id=n1,src=4.2.3.1,dst=1.2.3.4,udp,srcport=16384,dstport=16384,rxsession=0xffffffff,txsession=0xffffffff,counter
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="netdev~7"><a class="permalink" href="#netdev~7"><b><b>-netdev
    vde,id=id[,sock=socketpath][,port=n][,group=groupname][,mode=octalmode]</b></b></a></dt>
  <dd>Configure VDE backend to connect to PORT n of a vde switch running on host
      and listening for incoming connections on socketpath. Use GROUP groupname
      and MODE octalmode to change default ownership and permissions for
      communication port. This option is only available if QEMU has been
      compiled with vde support enabled.
    <p class="Pp">Example:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># launch vde switch
vde_switch -F -sock /tmp/myswitch
# launch QEMU instance
qemu-system-x86_64 linux.img -nic vde,sock=/tmp/myswitch
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="netdev~8"><a class="permalink" href="#netdev~8"><b><b>-netdev
    vhost-user,chardev=id[,vhostforce=on|off][,queues=n]</b></b></a></dt>
  <dd>Establish a vhost-user netdev, backed by a chardev id. The chardev should
      be a unix domain socket backed one. The vhost-user uses a specifically
      defined protocol to pass vhost ioctl replacement messages to an
      application on the other end of the socket. On non-MSIX guests, the
      feature can be forced with vhostforce. Use 'queues=n' to specify the
      number of queues to be created for multiqueue vhost-user.
    <p class="Pp">Example:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu -m 512 -object memory-backend-file,id=mem,size=512M,mem-path=/hugetlbfs,share=on \
<br/>
     -numa node,memdev=mem \
<br/>
     -chardev socket,id=chr0,path=/path/to/socket \
<br/>
     -netdev type=vhost-user,id=net0,chardev=chr0 \
<br/>
     -device virtio-net-pci,netdev=net0
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="netdev~9"><a class="permalink" href="#netdev~9"><b><b>-netdev
    vhost-vdpa,vhostdev=/path/to/dev</b></b></a></dt>
  <dd>Establish a vhost-vdpa netdev.
    <p class="Pp">vDPA device is a device that uses a datapath which complies
        with the virtio specifications with a vendor specific control path. vDPA
        devices can be both physically located on the hardware or emulated by
        software.</p>
  </dd>
  <dt id="netdev~10"><a class="permalink" href="#netdev~10"><b><b>-netdev
    hubport,id=id,hubid=hubid[,netdev=nd]</b></b></a></dt>
  <dd>Create a hub port on the emulated hub with ID hubid.
    <p class="Pp">The hubport netdev lets you connect a NIC to a QEMU emulated
        hub instead of a single netdev. Alternatively, you can also connect the
        hubport to another netdev with ID nd by using the <b>netdev=nd</b>
        option.</p>
  </dd>
  <dt id="net"><a class="permalink" href="#net"><b><b>-net
    nic[,netdev=nd][,macaddr=mac][,model=type]
    [,name=name][,addr=addr][,vectors=v]</b></b></a></dt>
  <dd>Legacy option to configure or create an on-board (or machine default)
      Network Interface Card(NIC) and connect it either to the emulated hub with
      ID 0 (i.e. the default hub), or to the netdev nd. If model is omitted,
      then the default NIC model associated with the machine type is used. Note
      that the default NIC model may change in future QEMU releases, so it is
      highly recommended to always specify a model. Optionally, the MAC address
      can be changed to mac, the device address set to addr (PCI cards only),
      and a name can be assigned for use in monitor commands. Optionally, for
      PCI cards, you can specify the number v of MSI-X vectors that the card
      should have; this option currently only affects virtio cards; set v = 0 to
      disable MSI-X. If no <b>-net</b> option is specified, a single NIC is
      created. QEMU can emulate several different models of network card. Use
      <b>-net nic,model=help</b> for a list of available devices for your
      target.</dd>
  <dt id="net~2"><a class="permalink" href="#net~2"><b><b>-net
    user|tap|bridge|socket|l2tpv3|vde[,...][,name=name]</b></b></a></dt>
  <dd>Configure a host network backend (with the options corresponding to the
      same <b>-netdev</b> option) and connect it to the emulated hub 0 (the
      default hub). Use name to specify the name of the hub port.</dd>
</dl>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Character_device_options"><a class="permalink" href="#Character_device_options">Character
  device options</a></h2>
<p class="Pp">The general form of a character device option is:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="chardev"><a class="permalink" href="#chardev"><b><b>-chardev
    backend,id=id[,mux=on|off][,options]</b></b></a></dt>
  <dd>Backend is one of: <b>null</b>, <b>socket</b>, <b>udp</b>, <b>msmouse</b>,
      <b>vc</b>, <b>ringbuf</b>, <b>file</b>, <b>pipe</b>, <b>console</b>,
      <b>serial</b>, <b>pty</b>, <b>stdio</b>, <b>braille</b>, <b>tty</b>,
      <b>parallel</b>, <b>parport</b>, <b>spicevmc</b>, <b>spiceport</b>. The
      specific backend will determine the applicable options.
    <p class="Pp">Use <b>-chardev help</b> to print all available chardev
        backend types.</p>
    <p class="Pp">All devices must have an id, which can be any string up to 127
        characters long. It is used to uniquely identify this device in other
        command line directives.</p>
    <p class="Pp">A character device may be used in multiplexing mode by
        multiple front-ends. Specify <b>mux=on</b> to enable this mode. A
        multiplexer is a &quot;1:N&quot; device, and here the &quot;1&quot; end
        is your specified chardev backend, and the &quot;N&quot; end is the
        various parts of QEMU that can talk to a chardev. If you create a
        chardev with <b>id=myid</b> and <b>mux=on</b>, QEMU will create a
        multiplexer with your specified ID, and you can then configure multiple
        front ends to use that chardev ID for their input/output. Up to four
        different front ends can be connected to a single multiplexed chardev.
        (Without multiplexing enabled, a chardev can only be used by a single
        front end.) For instance you could use this to allow a single stdio
        chardev to be used by two serial ports and the QEMU monitor:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-chardev stdio,mux=on,id=char0 \
-mon chardev=char0,mode=readline \
-serial chardev:char0 \
-serial chardev:char0
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">You can have more than one multiplexer in a system configuration;
    for instance you could have a TCP port multiplexed between UART 0 and UART
    1, and stdio multiplexed between the QEMU monitor and a parallel port:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-chardev stdio,mux=on,id=char0 \
-mon chardev=char0,mode=readline \
-parallel chardev:char0 \
-chardev tcp,...,mux=on,id=char1 \
-serial chardev:char1 \
-serial chardev:char1
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">When you're using a multiplexed character device, some escape
    sequences are interpreted in the input. See the chapter about <i>Keys in the
    character backend multiplexer</i> in the System Emulation Users Guide for
    more details.</p>
<p class="Pp">Note that some other command line options may implicitly create
    multiplexed character backends; for instance <b>-serial mon:stdio</b>
    creates a multiplexed stdio backend connected to the serial port and the
    QEMU monitor, and <b>-nographic</b> also multiplexes the console and the
    monitor to stdio.</p>
<p class="Pp">There is currently no support for multiplexing in the other
    direction (where a single QEMU front end takes input and output from
    multiple chardevs).</p>
<p class="Pp">Every backend supports the <b>logfile</b> option, which supplies
    the path to a file to record all data transmitted via the backend. The
    <b>logappend</b> option controls whether the log file will be truncated or
    appended to when opened.</p>
</div>
<br/>
<p class="Pp">The available backends are:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="chardev~2"><a class="permalink" href="#chardev~2"><b><b>-chardev
    null,id=id</b></b></a></dt>
  <dd>A void device. This device will not emit any data, and will drop any data
      it receives. The null backend does not take any options.</dd>
  <dt id="chardev~3"><a class="permalink" href="#chardev~3"><b><b>-chardev
    socket,id=id[,TCP options or unix
    options][,server=on|off][,wait=on|off][,telnet=on|off][,websocket=on|off][,reconnect=seconds][,tls-creds=id][,tls-authz=id]</b></b></a></dt>
  <dd>Create a two-way stream socket, which can be either a TCP or a unix
      socket. A unix socket will be created if <b>path</b> is specified.
      Behaviour is undefined if TCP options are specified for a unix socket.
    <p class="Pp"><b>server=on|off</b> specifies that the socket shall be a
        listening socket.</p>
    <p class="Pp"><b>wait=on|off</b> specifies that QEMU should not block
        waiting for a client to connect to a listening socket.</p>
    <p class="Pp"><b>telnet=on|off</b> specifies that traffic on the socket
        should interpret telnet escape sequences.</p>
    <p class="Pp"><b>websocket=on|off</b> specifies that the socket uses
        WebSocket protocol for communication.</p>
    <p class="Pp"><b>reconnect</b> sets the timeout for reconnecting on
        non-server sockets when the remote end goes away. qemu will delay this
        many seconds and then attempt to reconnect. Zero disables reconnecting,
        and is the default.</p>
    <p class="Pp"><b>tls-creds</b> requests enablement of the TLS protocol for
        encryption, and specifies the id of the TLS credentials to use for the
        handshake. The credentials must be previously created with the
        <b>-object tls-creds</b> argument.</p>
    <p class="Pp"><b>tls-auth</b> provides the ID of the QAuthZ authorization
        object against which the client's x509 distinguished name will be
        validated. This object is only resolved at time of use, so can be
        deleted and recreated on the fly while the chardev server is active. If
        missing, it will default to denying access.</p>
    <p class="Pp">TCP and unix socket options are given below:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="TCP"><a class="permalink" href="#TCP"><b><b>TCP options:
    port=port[,host=host][,to=to][,ipv4=on|off][,ipv6=on|off][,nodelay=on|off]</b></b></a></dt>
  <dd><b>host</b> for a listening socket specifies the local address to be
      bound. For a connecting socket species the remote host to connect to.
      <b>host</b> is optional for listening sockets. If not specified it
      defaults to <b>0.0.0.0</b>.
    <p class="Pp"><b>port</b> for a listening socket specifies the local port to
        be bound. For a connecting socket specifies the port on the remote host
        to connect to. <b>port</b> can be given as either a port number or a
        service name. <b>port</b> is required.</p>
    <p class="Pp"><b>to</b> is only relevant to listening sockets. If it is
        specified, and <b>port</b> cannot be bound, QEMU will attempt to bind to
        subsequent ports up to and including <b>to</b> until it succeeds.
        <b>to</b> must be specified as a port number.</p>
    <p class="Pp"><b>ipv4=on|off</b> and <b>ipv6=on|off</b> specify that either
        IPv4 or IPv6 must be used. If neither is specified the socket may use
        either protocol.</p>
    <p class="Pp"><b>nodelay=on|off</b> disables the Nagle algorithm.</p>
  </dd>
  <dt id="unix"><a class="permalink" href="#unix"><b><b>unix options:
    path=path[,abstract=on|off][,tight=on|off]</b></b></a></dt>
  <dd><b>path</b> specifies the local path of the unix socket. <b>path</b> is
      required. <b>abstract=on|off</b> specifies the use of the abstract socket
      namespace, rather than the filesystem. Optional, defaults to false.
      <b>tight=on|off</b> sets the socket length of abstract sockets to their
      minimum, rather than the full sun_path length. Optional, defaults to
    true.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="chardev~4"><a class="permalink" href="#chardev~4"><b><b>-chardev
    udp,id=id[,host=host],port=port[,localaddr=localaddr][,localport=localport][,ipv4=on|off][,ipv6=on|off]</b></b></a></dt>
  <dd>Sends all traffic from the guest to a remote host over UDP.
    <p class="Pp"><b>host</b> specifies the remote host to connect to. If not
        specified it defaults to <b>localhost</b>.</p>
    <p class="Pp"><b>port</b> specifies the port on the remote host to connect
        to. <b>port</b> is required.</p>
    <p class="Pp"><b>localaddr</b> specifies the local address to bind to. If
        not specified it defaults to <b>0.0.0.0</b>.</p>
    <p class="Pp"><b>localport</b> specifies the local port to bind to. If not
        specified any available local port will be used.</p>
    <p class="Pp"><b>ipv4=on|off</b> and <b>ipv6=on|off</b> specify that either
        IPv4 or IPv6 must be used. If neither is specified the device may use
        either protocol.</p>
  </dd>
  <dt id="chardev~5"><a class="permalink" href="#chardev~5"><b><b>-chardev
    msmouse,id=id</b></b></a></dt>
  <dd>Forward QEMU's emulated msmouse events to the guest. <b>msmouse</b> does
      not take any options.</dd>
  <dt id="chardev~6"><a class="permalink" href="#chardev~6"><b><b>-chardev
    vc,id=id[[,width=width][,height=height]][[,cols=cols][,rows=rows]]</b></b></a></dt>
  <dd>Connect to a QEMU text console. <b>vc</b> may optionally be given a
      specific size.
    <p class="Pp"><b>width</b> and <b>height</b> specify the width and height
        respectively of the console, in pixels.</p>
    <p class="Pp"><b>cols</b> and <b>rows</b> specify that the console be sized
        to fit a text console with the given dimensions.</p>
  </dd>
  <dt id="chardev~7"><a class="permalink" href="#chardev~7"><b><b>-chardev
    ringbuf,id=id[,size=size]</b></b></a></dt>
  <dd>Create a ring buffer with fixed size <b>size</b>. size must be a power of
      two and defaults to <b>64K</b>.</dd>
  <dt id="chardev~8"><a class="permalink" href="#chardev~8"><b><b>-chardev
    file,id=id,path=path</b></b></a></dt>
  <dd>Log all traffic received from the guest to a file.
    <p class="Pp"><b>path</b> specifies the path of the file to be opened. This
        file will be created if it does not already exist, and overwritten if it
        does. <b>path</b> is required.</p>
  </dd>
  <dt id="chardev~9"><a class="permalink" href="#chardev~9"><b><b>-chardev
    pipe,id=id,path=path</b></b></a></dt>
  <dd>Create a two-way connection to the guest. The behaviour differs slightly
      between Windows hosts and other hosts:
    <p class="Pp">On Windows, a single duplex pipe will be created at
        <b>\\.pipe\path</b>.</p>
    <p class="Pp">On other hosts, 2 pipes will be created called <b>path.in</b>
        and <b>path.out</b>. Data written to <b>path.in</b> will be received by
        the guest. Data written by the guest can be read from <b>path.out</b>.
        QEMU will not create these fifos, and requires them to be present.</p>
    <p class="Pp"><b>path</b> forms part of the pipe path as described above.
        <b>path</b> is required.</p>
  </dd>
  <dt id="chardev~10"><a class="permalink" href="#chardev~10"><b><b>-chardev
    console,id=id</b></b></a></dt>
  <dd>Send traffic from the guest to QEMU's standard output. <b>console</b> does
      not take any options.
    <p class="Pp"><b>console</b> is only available on Windows hosts.</p>
  </dd>
  <dt id="chardev~11"><a class="permalink" href="#chardev~11"><b><b>-chardev
    serial,id=id,path=path</b></b></a></dt>
  <dd>Send traffic from the guest to a serial device on the host.
    <p class="Pp">On Unix hosts serial will actually accept any tty device, not
        only serial lines.</p>
    <p class="Pp"><b>path</b> specifies the name of the serial device to
      open.</p>
  </dd>
  <dt id="chardev~12"><a class="permalink" href="#chardev~12"><b><b>-chardev
    pty,id=id</b></b></a></dt>
  <dd>Create a new pseudo-terminal on the host and connect to it. <b>pty</b>
      does not take any options.
    <p class="Pp"><b>pty</b> is not available on Windows hosts.</p>
  </dd>
  <dt id="chardev~13"><a class="permalink" href="#chardev~13"><b><b>-chardev
    stdio,id=id[,signal=on|off]</b></b></a></dt>
  <dd>Connect to standard input and standard output of the QEMU process.
    <p class="Pp"><b>signal</b> controls if signals are enabled on the terminal,
        that includes exiting QEMU with the key sequence Control-c. This option
        is enabled by default, use <b>signal=off</b> to disable it.</p>
  </dd>
  <dt id="chardev~14"><a class="permalink" href="#chardev~14"><b><b>-chardev
    braille,id=id</b></b></a></dt>
  <dd>Connect to a local BrlAPI server. <b>braille</b> does not take any
      options.</dd>
  <dt id="chardev~15"><a class="permalink" href="#chardev~15"><b><b>-chardev
    tty,id=id,path=path</b></b></a></dt>
  <dd><b>tty</b> is only available on Linux, Sun, FreeBSD, NetBSD, OpenBSD and
      DragonFlyBSD hosts. It is an alias for <b>serial</b>.
    <p class="Pp"><b>path</b> specifies the path to the tty. <b>path</b> is
        required.</p>
  </dd>
  <dt id="chardev~16"><a class="permalink" href="#chardev~16"><b><b>-chardev
    parallel,id=id,path=path</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="chardev~17"><a class="permalink" href="#chardev~17"><b><b>-chardev
    parport,id=id,path=path</b></b></a></dt>
  <dd><b>parallel</b> is only available on Linux, FreeBSD and DragonFlyBSD
      hosts.
    <p class="Pp">Connect to a local parallel port.</p>
    <p class="Pp"><b>path</b> specifies the path to the parallel port device.
        <b>path</b> is required.</p>
  </dd>
  <dt id="chardev~18"><a class="permalink" href="#chardev~18"><b><b>-chardev
    spicevmc,id=id,debug=debug,name=name</b></b></a></dt>
  <dd><b>spicevmc</b> is only available when spice support is built in.
    <p class="Pp"><b>debug</b> debug level for spicevmc</p>
    <p class="Pp"><b>name</b> name of spice channel to connect to</p>
    <p class="Pp">Connect to a spice virtual machine channel, such as
      vdiport.</p>
  </dd>
  <dt id="chardev~19"><a class="permalink" href="#chardev~19"><b><b>-chardev
    spiceport,id=id,debug=debug,name=name</b></b></a></dt>
  <dd><b>spiceport</b> is only available when spice support is built in.
    <p class="Pp"><b>debug</b> debug level for spicevmc</p>
    <p class="Pp"><b>name</b> name of spice port to connect to</p>
    <p class="Pp">Connect to a spice port, allowing a Spice client to handle the
        traffic identified by a name (preferably a fqdn).</p>
  </dd>
</dl>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="TPM_device_options"><a class="permalink" href="#TPM_device_options">TPM
  device options</a></h2>
<p class="Pp">The general form of a TPM device option is:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="tpmdev"><a class="permalink" href="#tpmdev"><b><b>-tpmdev
    backend,id=id[,options]</b></b></a></dt>
  <dd>The specific backend type will determine the applicable options. The
      <b>-tpmdev</b> option creates the TPM backend and requires a
      <b>-device</b> option that specifies the TPM frontend interface model.
    <p class="Pp">Use <b>-tpmdev help</b> to print all available TPM backend
        types.</p>
  </dd>
</dl>
</div>
<br/>
<p class="Pp">The available backends are:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="tpmdev~2"><a class="permalink" href="#tpmdev~2"><b><b>-tpmdev
    passthrough,id=id,path=path,cancel-path=cancel-path</b></b></a></dt>
  <dd>(Linux-host only) Enable access to the host's TPM using the passthrough
      driver.
    <p class="Pp"><b>path</b> specifies the path to the host's TPM device, i.e.,
        on a Linux host this would be <b>/dev/tpm0</b>. <b>path</b> is optional
        and by default <b>/dev/tpm0</b> is used.</p>
    <p class="Pp"><b>cancel-path</b> specifies the path to the host TPM device's
        sysfs entry allowing for cancellation of an ongoing TPM command.
        <b>cancel-path</b> is optional and by default QEMU will search for the
        sysfs entry to use.</p>
    <p class="Pp">Some notes about using the host's TPM with the passthrough
        driver:</p>
    <p class="Pp">The TPM device accessed by the passthrough driver must not be
        used by any other application on the host.</p>
    <p class="Pp">Since the host's firmware (BIOS/UEFI) has already initialized
        the TPM, the VM's firmware (BIOS/UEFI) will not be able to initialize
        the TPM again and may therefore not show a TPM-specific menu that would
        otherwise allow the user to configure the TPM, e.g., allow the user to
        enable/disable or activate/deactivate the TPM. Further, if TPM ownership
        is released from within a VM then the host's TPM will get disabled and
        deactivated. To enable and activate the TPM again afterwards, the host
        has to be rebooted and the user is required to enter the firmware's menu
        to enable and activate the TPM. If the TPM is left disabled and/or
        deactivated most TPM commands will fail.</p>
    <p class="Pp">To create a passthrough TPM use the following two options:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Note that the <b>-tpmdev</b> id is <b>tpm0</b> and is referenced
    by <b>tpmdev=tpm0</b> in the device option.</p>
<dl class="Bl-tag">
  <dt id="tpmdev~3"><a class="permalink" href="#tpmdev~3"><b><b>-tpmdev
    emulator,id=id,chardev=dev</b></b></a></dt>
  <dd>(Linux-host only) Enable access to a TPM emulator using Unix domain socket
      based chardev backend.
    <p class="Pp"><b>chardev</b> specifies the unique ID of a character device
        backend that provides connection to the software TPM server.</p>
    <p class="Pp">To create a TPM emulator backend device with chardev socket
        backend:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-chardev socket,id=chrtpm,path=/tmp/swtpm-sock -tpmdev emulator,id=tpm0,chardev=chrtpm -device tpm-tis,tpmdev=tpm0
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Linux/Multiboot_boot_specific"><a class="permalink" href="#Linux/Multiboot_boot_specific">Linux/Multiboot
  boot specific</a></h2>
<p class="Pp">When using these options, you can use a given Linux or Multiboot
    kernel without installing it in the disk image. It can be useful for easier
    testing of various kernels.</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="kernel~2"><a class="permalink" href="#kernel~2"><b><b>-kernel
    bzImage</b></b></a></dt>
  <dd>Use bzImage as kernel image. The kernel can be either a Linux kernel or in
      multiboot format.</dd>
  <dt id="append"><a class="permalink" href="#append"><b><b>-append
    cmdline</b></b></a></dt>
  <dd>Use cmdline as kernel command line</dd>
  <dt id="initrd"><a class="permalink" href="#initrd"><b><b>-initrd
    file</b></b></a></dt>
  <dd>Use file as initial ram disk.</dd>
  <dt id="initrd~2"><a class="permalink" href="#initrd~2"><b><b>-initrd file1
    arg=foo,file2 </b></b></a></dt>
  <dd>This syntax is only available with multiboot.
    <p class="Pp">Use file1 and file2 as modules and pass arg=foo as parameter
        to the first module.</p>
  </dd>
  <dt id="dtb"><a class="permalink" href="#dtb"><b><b>-dtb file</b></b></a></dt>
  <dd>Use file as a device tree binary (dtb) image and pass it to the kernel on
      boot.</dd>
</dl>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Debug/Expert_options"><a class="permalink" href="#Debug/Expert_options">Debug/Expert
  options</a></h2>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="compat"><a class="permalink" href="#compat"><b><b>-compat
    [deprecated-input=@var{input-policy}][,deprecated-output=@var{output-policy}]</b></b></a></dt>
  <dd>Set policy for handling deprecated management interfaces
    (experimental):</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="deprecated"><a class="permalink" href="#deprecated"><b><b>deprecated-input=accept</b>
    (default)</b></a></dt>
  <dd>Accept deprecated commands and arguments</dd>
  <dt id="deprecated~2"><a class="permalink" href="#deprecated~2"><b><b>deprecated-input=reject</b></b></a></dt>
  <dd>Reject deprecated commands and arguments</dd>
  <dt id="deprecated~3"><a class="permalink" href="#deprecated~3"><b><b>deprecated-input=crash</b></b></a></dt>
  <dd>Crash on deprecated commands and arguments</dd>
  <dt id="deprecated~4"><a class="permalink" href="#deprecated~4"><b><b>deprecated-output=accept</b>
    (default)</b></a></dt>
  <dd>Emit deprecated command results and events</dd>
  <dt id="deprecated~5"><a class="permalink" href="#deprecated~5"><b><b>deprecated-output=hide</b></b></a></dt>
  <dd>Suppress deprecated command results and events</dd>
</dl>
</div>
<br/>
<p class="Pp">Limitation: covers only syntactic aspects of QMP.</p>
<dl class="Bl-tag">
  <dt id="compat~2"><a class="permalink" href="#compat~2"><b><b>-compat
    [unstable-input=@var{input-policy}][,unstable-output=@var{output-policy}]</b></b></a></dt>
  <dd>Set policy for handling unstable management interfaces
    (experimental):</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="unstable"><a class="permalink" href="#unstable"><b><b>unstable-input=accept</b>
    (default)</b></a></dt>
  <dd>Accept unstable commands and arguments</dd>
  <dt id="unstable~2"><a class="permalink" href="#unstable~2"><b><b>unstable-input=reject</b></b></a></dt>
  <dd>Reject unstable commands and arguments</dd>
  <dt id="unstable~3"><a class="permalink" href="#unstable~3"><b><b>unstable-input=crash</b></b></a></dt>
  <dd>Crash on unstable commands and arguments</dd>
  <dt id="unstable~4"><a class="permalink" href="#unstable~4"><b><b>unstable-output=accept</b>
    (default)</b></a></dt>
  <dd>Emit unstable command results and events</dd>
  <dt id="unstable~5"><a class="permalink" href="#unstable~5"><b><b>unstable-output=hide</b></b></a></dt>
  <dd>Suppress unstable command results and events</dd>
</dl>
</div>
<br/>
<p class="Pp">Limitation: covers only syntactic aspects of QMP.</p>
<dl class="Bl-tag">
  <dt id="fw_cfg"><a class="permalink" href="#fw_cfg"><b><b>-fw_cfg
    [name=]name,file=file</b></b></a></dt>
  <dd>Add named fw_cfg entry with contents from file file.</dd>
  <dt id="fw_cfg~2"><a class="permalink" href="#fw_cfg~2"><b><b>-fw_cfg
    [name=]name,string=str</b></b></a></dt>
  <dd>Add named fw_cfg entry with contents from string str.
    <p class="Pp">The terminating NUL character of the contents of str will not
        be included as part of the fw_cfg item data. To insert contents with
        embedded NUL characters, you have to use the file parameter.</p>
    <p class="Pp">The fw_cfg entries are passed by QEMU through to the
      guest.</p>
    <p class="Pp">Example:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-fw_cfg name=opt/com.mycompany/blob,file=./my_blob.bin
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">creates an fw_cfg entry named opt/com.mycompany/blob with contents
    from ./my_blob.bin.</p>
<dl class="Bl-tag">
  <dt id="serial"><a class="permalink" href="#serial"><b><b>-serial
    dev</b></b></a></dt>
  <dd>Redirect the virtual serial port to host character device dev. The default
      device is <b>vc</b> in graphical mode and <b>stdio</b> in non graphical
      mode.
    <p class="Pp">This option can be used several times to simulate up to 4
        serial ports.</p>
    <p class="Pp">Use <b>-serial none</b> to disable all serial ports.</p>
    <p class="Pp">Available character devices are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="vc_:WxH_"><a class="permalink" href="#vc_:WxH_"><b><b>vc[:WxH]</b></b></a></dt>
  <dd>Virtual console. Optionally, a width and height can be given in pixel
    with</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>vc:800x600
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">It is also possible to specify width or height in characters:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>vc:80Cx24C
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="pty"><a class="permalink" href="#pty"><b><b>pty</b></b></a></dt>
  <dd>[Linux only] Pseudo TTY (a new PTY is automatically allocated)</dd>
  <dt id="none~4"><a class="permalink" href="#none~4"><b><b>none</b></b></a></dt>
  <dd>No device is allocated.</dd>
  <dt id="null"><a class="permalink" href="#null"><b><b>null</b></b></a></dt>
  <dd>void device</dd>
  <dt id="chardev:id"><a class="permalink" href="#chardev:id"><b><b>chardev:id</b></b></a></dt>
  <dd>Use a named character device defined with the <b>-chardev</b> option.</dd>
  <dt><b><b>/dev/XXX</b></b></dt>
  <dd>[Linux only] Use host tty, e.g. <b>/dev/ttyS0</b>. The host serial port
      parameters are set according to the emulated ones.</dd>
  <dt><b><b>/dev/parportN</b></b></dt>
  <dd>[Linux only, parallel port only] Use host parallel port N. Currently SPP
      and EPP parallel port features can be used.</dd>
  <dt id="file:filename"><a class="permalink" href="#file:filename"><b><b>file:filename</b></b></a></dt>
  <dd>Write output to filename. No character can be read.</dd>
  <dt id="stdio"><a class="permalink" href="#stdio"><b><b>stdio</b></b></a></dt>
  <dd>[Unix only] standard input/output</dd>
  <dt id="pipe:filename"><a class="permalink" href="#pipe:filename"><b><b>pipe:filename</b></b></a></dt>
  <dd>name pipe filename</dd>
  <dt id="COMn"><a class="permalink" href="#COMn"><b><b>COMn</b></b></a></dt>
  <dd>[Windows only] Use host serial port n</dd>
  <dt id="udp:_remote_host_:remote_port_@_src_ip_:src_port_"><a class="permalink" href="#udp:_remote_host_:remote_port_@_src_ip_:src_port_"><b><b>udp:[remote_host]:remote_port[@[src_ip]:src_port]</b></b></a></dt>
  <dd>This implements UDP Net Console. When remote_host or src_ip are not
      specified they default to <b>0.0.0.0</b>. When not using a specified
      src_port a random port is automatically chosen.
    <p class="Pp">If you just want a simple readonly console you can use
        <b>netcat</b> or <b>nc</b>, by starting QEMU with: <b>-serial
        udp::4555</b> and nc as: <b>nc -u -l -p 4555</b>. Any time QEMU writes
        something to that port it will appear in the netconsole session.</p>
    <p class="Pp">If you plan to send characters back via netconsole or you want
        to stop and start QEMU a lot of times, you should have QEMU use the same
        source port each time by using something like <b>-serial</b>
        <b>udp::4555@:4556</b> to QEMU. Another approach is to use a patched
        version of netcat which can listen to a TCP port and send and receive
        characters via udp. If you have a patched version of netcat which
        activates telnet remote echo and single char transfer, then you can use
        the following options to set up a netcat redirector to allow telnet on
        port 5555 to access the QEMU port.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="QEMU"><a class="permalink" href="#QEMU"><b><b>QEMU
    Options:</b></b></a></dt>
  <dd>-serial udp::4555@:4556</dd>
  <dt id="netcat"><a class="permalink" href="#netcat"><b><b>netcat
    options:</b></b></a></dt>
  <dd>-u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T</dd>
  <dt id="telnet"><a class="permalink" href="#telnet"><b><b>telnet
    options:</b></b></a></dt>
  <dd>localhost 5555</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="tcp:_host_:port_,server=on_off__,wait=on_off__,nodelay=on_off__,reconnect=seconds_"><a class="permalink" href="#tcp:_host_:port_,server=on_off__,wait=on_off__,nodelay=on_off__,reconnect=seconds_"><b><b>tcp:[host]:port[,server=on|off][,wait=on|off][,nodelay=on|off][,reconnect=seconds]</b></b></a></dt>
  <dd>The TCP Net Console has two modes of operation. It can send the serial I/O
      to a location or wait for a connection from a location. By default the TCP
      Net Console is sent to host at the port. If you use the <b>server=on</b>
      option QEMU will wait for a client socket application to connect to the
      port before continuing, unless the <b>wait=on|off</b> option was
      specified. The <b>nodelay=on|off</b> option disables the Nagle buffering
      algorithm. The <b>reconnect=on</b> option only applies if <b>server=no</b>
      is set, if the connection goes down it will attempt to reconnect at the
      given interval. If host is omitted, 0.0.0.0 is assumed. Only one TCP
      connection at a time is accepted. You can use <b>telnet=on</b> to connect
      to the corresponding character device.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Example"><a class="permalink" href="#Example"><b><b>Example to send
    tcp console to 192.168.0.2 port 4444</b></b></a></dt>
  <dd>-serial <i>tcp:192.168.0.2:4444</i></dd>
  <dt id="Example~2"><a class="permalink" href="#Example~2"><b><b>Example to
    listen and wait on port 4444 for connection</b></b></a></dt>
  <dd>-serial <i>tcp::4444,server=on</i></dd>
  <dt id="Example~3"><a class="permalink" href="#Example~3"><b><b>Example to not
    wait and listen on ip 192.168.0.100 port 4444</b></b></a></dt>
  <dd>-serial <i>tcp:192.168.0.100:4444,server=on,wait=off</i></dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="telnet:host:port_,server=on_off__,wait=on_off__,nodelay=on_off_"><a class="permalink" href="#telnet:host:port_,server=on_off__,wait=on_off__,nodelay=on_off_"><b><b>telnet:host:port[,server=on|off][,wait=on|off][,nodelay=on|off]</b></b></a></dt>
  <dd>The telnet protocol is used instead of raw tcp sockets. The options work
      the same as if you had specified <b>-serial tcp</b>. The difference is
      that the port acts like a telnet server or client using telnet option
      negotiation. This will also allow you to send the MAGIC_SYSRQ sequence if
      you use a telnet that supports sending the break sequence. Typically in
      unix telnet you do it with Control-] and then type &quot;send break&quot;
      followed by pressing the enter key.</dd>
  <dt id="websocket:host:port,server=on_,wait=on_off__,nodelay=on_off_"><a class="permalink" href="#websocket:host:port,server=on_,wait=on_off__,nodelay=on_off_"><b><b>websocket:host:port,server=on[,wait=on|off][,nodelay=on|off]</b></b></a></dt>
  <dd>The WebSocket protocol is used instead of raw tcp socket. The port acts as
      a WebSocket server. Client mode is not supported.</dd>
  <dt id="unix:path_,server=on_off__,wait=on_off__,reconnect=seconds_"><a class="permalink" href="#unix:path_,server=on_off__,wait=on_off__,reconnect=seconds_"><b><b>unix:path[,server=on|off][,wait=on|off][,reconnect=seconds]</b></b></a></dt>
  <dd>A unix domain socket is used instead of a tcp socket. The option works the
      same as if you had specified <b>-serial tcp</b> except the unix domain
      socket path is used for connections.</dd>
  <dt id="mon:dev_string"><a class="permalink" href="#mon:dev_string"><b><b>mon:dev_string</b></b></a></dt>
  <dd>This is a special option to allow the monitor to be multiplexed onto
      another serial port. The monitor is accessed with key sequence of
      Control-a and then pressing c. dev_string should be any one of the serial
      devices specified above. An example to multiplex the monitor onto a telnet
      server listening on port 4444 would be:
    <p class="Pp"><b>-serial mon:telnet::4444,server=on,wait=off</b></p>
    <p class="Pp">When the monitor is multiplexed to stdio in this way, Ctrl+C
        will not terminate QEMU any more but will be passed to the guest
        instead.</p>
  </dd>
  <dt id="braille~2"><a class="permalink" href="#braille~2"><b><b>braille</b></b></a></dt>
  <dd>Braille device. This will use BrlAPI to display the braille output on a
      real or fake device.</dd>
  <dt id="msmouse"><a class="permalink" href="#msmouse"><b><b>msmouse</b></b></a></dt>
  <dd>Three button serial mouse. Configure the guest to use Microsoft
    protocol.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="parallel"><a class="permalink" href="#parallel"><b><b>-parallel
    dev</b></b></a></dt>
  <dd>Redirect the virtual parallel port to host device dev (same devices as the
      serial port). On Linux hosts, <b>/dev/parportN</b> can be used to use
      hardware devices connected on the corresponding host parallel port.
    <p class="Pp">This option can be used several times to simulate up to 3
        parallel ports.</p>
    <p class="Pp">Use <b>-parallel none</b> to disable all parallel ports.</p>
  </dd>
  <dt id="monitor"><a class="permalink" href="#monitor"><b><b>-monitor
    dev</b></b></a></dt>
  <dd>Redirect the monitor to host device dev (same devices as the serial port).
      The default device is <b>vc</b> in graphical mode and <b>stdio</b> in non
      graphical mode. Use <b>-monitor none</b> to disable the default
    monitor.</dd>
  <dt id="qmp"><a class="permalink" href="#qmp"><b><b>-qmp dev</b></b></a></dt>
  <dd>Like -monitor but opens in 'control' mode.</dd>
  <dt id="qmp~2"><a class="permalink" href="#qmp~2"><b><b>-qmp-pretty
    dev</b></b></a></dt>
  <dd>Like -qmp but uses pretty JSON formatting.</dd>
  <dt id="mon"><a class="permalink" href="#mon"><b><b>-mon
    [chardev=]name[,mode=readline|control][,pretty[=on|off]]</b></b></a></dt>
  <dd>Setup monitor on chardev name. <b>mode=control</b> configures a QMP
      monitor (a JSON RPC-style protocol) and it is not the same as HMP, the
      human monitor that has a &quot;(qemu)&quot; prompt. <b>pretty</b> is only
      valid when <b>mode=control</b>, turning on JSON pretty printing to ease
      human reading and debugging.</dd>
  <dt id="debugcon"><a class="permalink" href="#debugcon"><b><b>-debugcon
    dev</b></b></a></dt>
  <dd>Redirect the debug console to host device dev (same devices as the serial
      port). The debug console is an I/O port which is typically port 0xe9;
      writing to that I/O port sends output to this device. The default device
      is <b>vc</b> in graphical mode and <b>stdio</b> in non graphical
    mode.</dd>
  <dt id="pidfile"><a class="permalink" href="#pidfile"><b><b>-pidfile
    file</b></b></a></dt>
  <dd>Store the QEMU process PID in file. It is useful if you launch QEMU from a
      script.</dd>
  <dt id="singlestep"><a class="permalink" href="#singlestep"><b><b>-singlestep</b></b></a></dt>
  <dd>Run the emulation in single step mode.</dd>
  <dt id="preconfig"><a class="permalink" href="#preconfig"><b><b>--preconfig</b></b></a></dt>
  <dd>Pause QEMU for interactive configuration before the machine is created,
      which allows querying and configuring properties that will affect machine
      initialization. Use QMP command 'x-exit-preconfig' to exit the preconfig
      state and move to the next state (i.e. run guest if -S isn't used or pause
      the second time if -S is used). This option is experimental.</dd>
  <dt id="S"><a class="permalink" href="#S"><b><b>-S</b></b></a></dt>
  <dd>Do not start CPU at startup (you must type 'c' in the monitor).</dd>
  <dt id="overcommit"><a class="permalink" href="#overcommit"><b><b>-overcommit
    mem-lock=on|off</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="overcommit~2"><a class="permalink" href="#overcommit~2"><b><b>-overcommit
    cpu-pm=on|off</b></b></a></dt>
  <dd>Run qemu with hints about host resource overcommit. The default is to
      assume that host overcommits all resources.
    <p class="Pp">Locking qemu and guest memory can be enabled via
        <b>mem-lock=on</b> (disabled by default). This works when host memory is
        not overcommitted and reduces the worst-case latency for guest.</p>
    <p class="Pp">Guest ability to manage power state of host cpus (increasing
        latency for other processes on the same host cpu, but decreasing latency
        for guest) can be enabled via <b>cpu-pm=on</b> (disabled by default).
        This works best when host CPU is not overcommitted. When used, host
        estimates of CPU cycle and power utilization will be incorrect, not
        taking into account guest idle time.</p>
  </dd>
  <dt id="gdb"><a class="permalink" href="#gdb"><b><b>-gdb dev</b></b></a></dt>
  <dd>Accept a gdb connection on device dev (see the <i>GDB usage</i> chapter in
      the System Emulation Users Guide). Note that this option does not pause
      QEMU execution -- if you want QEMU to not start the guest until you
      connect with gdb and issue a <b>continue</b> command, you will need to
      also pass the <b>-S</b> option to QEMU.
    <p class="Pp">The most usual configuration is to listen on a local TCP
        socket:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-gdb tcp::3117
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">but you can specify other backends; UDP, pseudo TTY, or even stdio
    are all reasonable use cases. For example, a stdio connection allows you to
    start QEMU from within gdb and establish the connection via a pipe:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>(gdb) target remote | exec qemu-system-x86_64 -gdb stdio ...
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="s"><a class="permalink" href="#s"><b><b>-s</b></b></a></dt>
  <dd>Shorthand for -gdb <i>tcp::1234</i>, i.e. open a gdbserver on TCP port
      1234 (see the <i>GDB usage</i> chapter in the System Emulation Users
      Guide).</dd>
  <dt id="d"><a class="permalink" href="#d"><b><b>-d
    item1[,...]</b></b></a></dt>
  <dd>Enable logging of specified items. Use '-d help' for a list of log
    items.</dd>
  <dt id="D"><a class="permalink" href="#D"><b><b>-D logfile</b></b></a></dt>
  <dd>Output log in logfile instead of to stderr</dd>
  <dt id="dfilter"><a class="permalink" href="#dfilter"><b><b>-dfilter
    range1[,...]</b></b></a></dt>
  <dd>Filter debug output to that relevant to a range of target addresses. The
      filter spec can be either start+size, start-size or start..end where start
      end and size are the addresses and sizes required. For example:</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>-dfilter 0x8000..0x8fff,0xffffffc000080000+0x200,0xffffffc000060000-0x1000
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Will dump output for any code in the 0x1000 sized block starting
    at 0x8000 and the 0x200 sized block starting at 0xffffffc000080000 and
    another 0x1000 sized block starting at 0xffffffc00005f000.</p>
<dl class="Bl-tag">
  <dt id="seed"><a class="permalink" href="#seed"><b><b>-seed
    number</b></b></a></dt>
  <dd>Force the guest to use a deterministic pseudo-random number generator,
      seeded with number. This does not affect crypto routines within the
    host.</dd>
  <dt id="L"><a class="permalink" href="#L"><b><b>-L path</b></b></a></dt>
  <dd>Set the directory for the BIOS, VGA BIOS and keymaps.
    <p class="Pp">To list all the data directories, use <b>-L help</b>.</p>
  </dd>
  <dt id="bios"><a class="permalink" href="#bios"><b><b>-bios
    file</b></b></a></dt>
  <dd>Set the filename for the BIOS.</dd>
  <dt id="enable"><a class="permalink" href="#enable"><b><b>-enable-kvm</b></b></a></dt>
  <dd>Enable KVM full virtualization support. This option is only available if
      KVM support is enabled when compiling.</dd>
  <dt id="xen"><a class="permalink" href="#xen"><b><b>-xen-domid
    id</b></b></a></dt>
  <dd>Specify xen guest domain id (XEN only).</dd>
  <dt id="xen~2"><a class="permalink" href="#xen~2"><b><b>-xen-attach</b></b></a></dt>
  <dd>Attach to existing xen domain. libxl will use this when starting QEMU (XEN
      only). Restrict set of available xen operations to specified domain id
      (XEN only).</dd>
  <dt id="no~4"><a class="permalink" href="#no~4"><b><b>-no-reboot</b></b></a></dt>
  <dd>Exit instead of rebooting.</dd>
  <dt id="no~5"><a class="permalink" href="#no~5"><b><b>-no-shutdown</b></b></a></dt>
  <dd>Don't exit QEMU on guest shutdown, but instead only stop the emulation.
      This allows for instance switching to monitor to commit changes to the
      disk image.</dd>
  <dt id="action"><a class="permalink" href="#action"><b><b>-action
    event=action</b></b></a></dt>
  <dd>The action parameter serves to modify QEMU's default behavior when certain
      guest events occur. It provides a generic method for specifying the same
      behaviors that are modified by the <b>-no-reboot</b> and
      <b>-no-shutdown</b> parameters.
    <p class="Pp">Examples:</p>
    <p class="Pp"><b>-action panic=none</b> <b>-action
        reboot=shutdown,shutdown=pause</b> <b>-watchdog i6300esb -action
        watchdog=pause</b></p>
  </dd>
  <dt id="loadvm"><a class="permalink" href="#loadvm"><b><b>-loadvm
    file</b></b></a></dt>
  <dd>Start right away with a saved state (<b>loadvm</b> in monitor)</dd>
  <dt id="daemonize"><a class="permalink" href="#daemonize"><b><b>-daemonize</b></b></a></dt>
  <dd>Daemonize the QEMU process after initialization. QEMU will not detach from
      standard IO until it is ready to receive connections on any of its
      devices. This option is a useful way for external programs to launch QEMU
      without having to cope with initialization race conditions.</dd>
  <dt id="option"><a class="permalink" href="#option"><b><b>-option-rom
    file</b></b></a></dt>
  <dd>Load the contents of file as an option ROM. This option is useful to load
      things like EtherBoot.</dd>
  <dt id="rtc"><a class="permalink" href="#rtc"><b><b>-rtc
    [base=utc|localtime|datetime][,clock=host|rt|vm][,driftfix=none|slew]</b></b></a></dt>
  <dd>Specify <b>base</b> as <b>utc</b> or <b>localtime</b> to let the RTC start
      at the current UTC or local time, respectively. <b>localtime</b> is
      required for correct date in MS-DOS or Windows. To start at a specific
      point in time, provide datetime in the format <b>2006-06-17T16:01:21</b>
      or <b>2006-06-17</b>. The default base is UTC.
    <p class="Pp">By default the RTC is driven by the host system time. This
        allows using of the RTC as accurate reference clock inside the guest,
        specifically if the host time is smoothly following an accurate external
        reference clock, e.g. via NTP. If you want to isolate the guest time
        from the host, you can set <b>clock</b> to <b>rt</b> instead, which
        provides a host monotonic clock if host support it. To even prevent the
        RTC from progressing during suspension, you can set <b>clock</b> to
        <b>vm</b> (virtual clock). '<b>clock=vm</b>' is recommended especially
        in icount mode in order to preserve determinism; however, note that in
        icount mode the speed of the virtual clock is variable and can in
        general differ from the host clock.</p>
    <p class="Pp">Enable <b>driftfix</b> (i386 targets only) if you experience
        time drift problems, specifically with Windows' ACPI HAL. This option
        will try to figure out how many timer interrupts were not processed by
        the Windows guest and will re-inject them.</p>
  </dd>
  <dt id="icount"><a class="permalink" href="#icount"><b><b>-icount
    [shift=N|auto][,align=on|off][,sleep=on|off][,rr=record|replay,rrfile=filename[,rrsnapshot=snapshot]]</b></b></a></dt>
  <dd>Enable virtual instruction counter. The virtual cpu will execute one
      instruction every 2^N ns of virtual time. If <b>auto</b> is specified then
      the virtual cpu speed will be automatically adjusted to keep virtual time
      within a few seconds of real time.
    <p class="Pp">Note that while this option can give deterministic behavior,
        it does not provide cycle accurate emulation. Modern CPUs contain
        superscalar out of order cores with complex cache hierarchies. The
        number of instructions executed often has little or no correlation with
        actual performance.</p>
    <p class="Pp">When the virtual cpu is sleeping, the virtual time will
        advance at default speed unless <b>sleep=on</b> is specified. With
        <b>sleep=on</b>, the virtual time will jump to the next timer deadline
        instantly whenever the virtual cpu goes to sleep mode and will not
        advance if no timer is enabled. This behavior gives deterministic
        execution times from the guest point of view. The default if icount is
        enabled is <b>sleep=off</b>. <b>sleep=on</b> cannot be used together
        with either <b>shift=auto</b> or <b>align=on</b>.</p>
    <p class="Pp"><b>align=on</b> will activate the delay algorithm which will
        try to synchronise the host clock and the virtual clock. The goal is to
        have a guest running at the real frequency imposed by the shift option.
        Whenever the guest clock is behind the host clock and if <b>align=on</b>
        is specified then we print a message to the user to inform about the
        delay. Currently this option does not work when <b>shift</b> is
        <b>auto</b>. Note: The sync algorithm will work for those shift values
        for which the guest clock runs ahead of the host clock. Typically this
        happens when the shift value is high (how high depends on the host
        machine). The default if icount is enabled is <b>align=off</b>.</p>
    <p class="Pp">When the <b>rr</b> option is specified deterministic
        record/replay is enabled. The <b>rrfile=</b> option must also be
        provided to specify the path to the replay log. In record mode data is
        written to this file, and in replay mode it is read back. If the
        <b>rrsnapshot</b> option is given then it specifies a VM snapshot name.
        In record mode, a new VM snapshot with the given name is created at the
        start of execution recording. In replay mode this option specifies the
        snapshot name used to load the initial VM state.</p>
  </dd>
  <dt id="watchdog"><a class="permalink" href="#watchdog"><b><b>-watchdog
    model</b></b></a></dt>
  <dd>Create a virtual hardware watchdog device. Once enabled (by a guest
      action), the watchdog must be periodically polled by an agent inside the
      guest or else the guest will be restarted. Choose a model for which your
      guest has drivers.
    <p class="Pp">The model is the model of hardware watchdog to emulate. Use
        <b>-watchdog help</b> to list available hardware models. Only one
        watchdog can be enabled for a guest.</p>
    <p class="Pp">The following models may be available:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="ib700"><a class="permalink" href="#ib700"><b><b>ib700</b></b></a></dt>
  <dd>iBASE 700 is a very simple ISA watchdog with a single timer.</dd>
  <dt id="i6300esb"><a class="permalink" href="#i6300esb"><b><b>i6300esb</b></b></a></dt>
  <dd>Intel 6300ESB I/O controller hub is a much more featureful PCI-based
      dual-timer watchdog.</dd>
  <dt id="diag288"><a class="permalink" href="#diag288"><b><b>diag288</b></b></a></dt>
  <dd>A virtual watchdog for s390x backed by the diagnose 288 hypercall
      (currently KVM only).</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="watchdog~2"><a class="permalink" href="#watchdog~2"><b><b>-watchdog-action
    action</b></b></a></dt>
  <dd>The action controls what QEMU will do when the watchdog timer expires. The
      default is <b>reset</b> (forcefully reset the guest). Other possible
      actions are: <b>shutdown</b> (attempt to gracefully shutdown the guest),
      <b>poweroff</b> (forcefully poweroff the guest), <b>inject-nmi</b> (inject
      a NMI into the guest), <b>pause</b> (pause the guest), <b>debug</b> (print
      a debug message and continue), or <b>none</b> (do nothing).
    <p class="Pp">Note that the <b>shutdown</b> action requires that the guest
        responds to ACPI signals, which it may not be able to do in the sort of
        situations where the watchdog would have expired, and thus
        <b>-watchdog-action shutdown</b> is not recommended for production
      use.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"><b>-watchdog i6300esb -watchdog-action pause</b>; <b>-watchdog
        ib700</b></p>
  </dd>
  <dt id="echr"><a class="permalink" href="#echr"><b><b>-echr
    numeric_ascii_value</b></b></a></dt>
  <dd>Change the escape character used for switching to the monitor when using
      monitor and serial sharing. The default is <b>0x01</b> when using the
      <b>-nographic</b> option. <b>0x01</b> is equal to pressing
      <b>Control-a</b>. You can select a different character from the ascii
      control keys where 1 through 26 map to Control-a through Control-z. For
      instance you could use the either of the following to change the escape
      character to Control-t.
    <p class="Pp"><b>-echr 0x14</b>; <b>-echr 20</b></p>
  </dd>
  <dt id="incoming"><a class="permalink" href="#incoming"><b><b>-incoming
    tcp:[host]:port[,to=maxport][,ipv4=on|off][,ipv6=on|off]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="incoming~2"><a class="permalink" href="#incoming~2"><b><b>-incoming
    rdma:host:port[,ipv4=on|off][,ipv6=on|off]</b></b></a></dt>
  <dd>Prepare for incoming migration, listen on a given tcp port.</dd>
  <dt id="incoming~3"><a class="permalink" href="#incoming~3"><b><b>-incoming
    unix:socketpath</b></b></a></dt>
  <dd>Prepare for incoming migration, listen on a given unix socket.</dd>
  <dt id="incoming~4"><a class="permalink" href="#incoming~4"><b><b>-incoming
    fd:fd</b></b></a></dt>
  <dd>Accept incoming migration from a given filedescriptor.</dd>
  <dt id="incoming~5"><a class="permalink" href="#incoming~5"><b><b>-incoming
    exec:cmdline</b></b></a></dt>
  <dd>Accept incoming migration as an output from specified external
    command.</dd>
  <dt id="incoming~6"><a class="permalink" href="#incoming~6"><b><b>-incoming
    defer</b></b></a></dt>
  <dd>Wait for the URI to be specified via migrate_incoming. The monitor can be
      used to change settings (such as migration parameters) prior to issuing
      the migrate_incoming to allow the migration to begin.</dd>
  <dt id="only"><a class="permalink" href="#only"><b><b>-only-migratable</b></b></a></dt>
  <dd>Only allow migratable devices. Devices will not be allowed to enter an
      unmigratable state.</dd>
  <dt id="nodefaults"><a class="permalink" href="#nodefaults"><b><b>-nodefaults</b></b></a></dt>
  <dd>Don't create default devices. Normally, QEMU sets the default devices like
      serial port, parallel port, virtual console, monitor device, VGA adapter,
      floppy and CD-ROM drive and others. The <b>-nodefaults</b> option will
      disable all those default devices.</dd>
  <dt id="chroot"><a class="permalink" href="#chroot"><b><b>-chroot
    dir</b></b></a></dt>
  <dd>Immediately before starting guest execution, chroot to the specified
      directory. Especially useful in combination with -runas.</dd>
  <dt id="runas"><a class="permalink" href="#runas"><b><b>-runas
    user</b></b></a></dt>
  <dd>Immediately before starting guest execution, drop root privileges,
      switching to the specified user.</dd>
  <dt id="prom"><a class="permalink" href="#prom"><b><b>-prom-env
    variable=value</b></b></a></dt>
  <dd>Set OpenBIOS nvram variable to given value (PPC, SPARC only).</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-sparc -prom-env 'auto-boot?=false' \
<br/>
 -prom-env 'boot-device=sd(0,2,0):d' -prom-env 'boot-args=linux single'
</pre>
</div>
<br/>
</div>
<br/>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-ppc -prom-env 'auto-boot?=false' \
<br/>
 -prom-env 'boot-device=hd:2,\yaboot' \
<br/>
 -prom-env 'boot-args=conf=hd:2,\yaboot.conf'
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="semihosting"><a class="permalink" href="#semihosting"><b><b>-semihosting</b></b></a></dt>
  <dd>Enable semihosting mode (ARM, M68K, Xtensa, MIPS, Nios II, RISC-V only).
    <p class="Pp">Note that this allows guest direct access to the host
        filesystem, so should only be used with a trusted guest OS.</p>
    <p class="Pp">See the -semihosting-config option documentation for further
        information about the facilities this enables.</p>
  </dd>
  <dt id="semihosting~2"><a class="permalink" href="#semihosting~2"><b><b>-semihosting-config
    [enable=on|off][,target=native|gdb|auto][,chardev=id][,arg=str[,...]]</b></b></a></dt>
  <dd>Enable and configure semihosting (ARM, M68K, Xtensa, MIPS, Nios II, RISC-V
      only).
    <p class="Pp">Note that this allows guest direct access to the host
        filesystem, so should only be used with a trusted guest OS.</p>
    <p class="Pp">On Arm this implements the standard semihosting API, version
        2.0.</p>
    <p class="Pp">On M68K this implements the &quot;ColdFire GDB&quot; interface
        used by libgloss.</p>
    <p class="Pp">Xtensa semihosting provides basic file IO calls, such as
        open/read/write/seek/select. Tensilica baremetal libc for ISS and linux
        platform &quot;sim&quot; use this interface.</p>
    <p class="Pp">On RISC-V this implements the standard semihosting API,
        version 0.2.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="target=native_gdb_auto"><a class="permalink" href="#target=native_gdb_auto"><b><b>target=native|gdb|auto</b></b></a></dt>
  <dd>Defines where the semihosting calls will be addressed, to QEMU
      (<b>native</b>) or to GDB (<b>gdb</b>). The default is <b>auto</b>, which
      means <b>gdb</b> during debug sessions and <b>native</b> otherwise.</dd>
  <dt id="chardev=str1"><a class="permalink" href="#chardev=str1"><b><b>chardev=str1</b></b></a></dt>
  <dd>Send the output to a chardev backend output for native or auto output when
      not in gdb</dd>
  <dt id="arg=str1,arg=str2,..."><a class="permalink" href="#arg=str1,arg=str2,..."><b><b>arg=str1,arg=str2,...</b></b></a></dt>
  <dd>Allows the user to pass input arguments, and can be used multiple times to
      build up a list. The old-style <b>-kernel</b>/<b>-append</b> method of
      passing a command line is still supported for backward compatibility. If
      both the <b>--semihosting-config arg</b> and the
      <b>-kernel</b>/<b>-append</b> are specified, the former is passed to
      semihosting as it always takes precedence.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="old"><a class="permalink" href="#old"><b><b>-old-param</b></b></a></dt>
  <dd>Old param mode (ARM only).</dd>
  <dt id="sandbox"><a class="permalink" href="#sandbox"><b><b>-sandbox
    arg[,obsolete=string][,elevateprivileges=string][,spawn=string][,resourcecontrol=string]</b></b></a></dt>
  <dd>Enable Seccomp mode 2 system call filter. 'on' will enable syscall
      filtering and 'off' will disable it. The default is 'off'.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="obsolete=string"><a class="permalink" href="#obsolete=string"><b><b>obsolete=string</b></b></a></dt>
  <dd>Enable Obsolete system calls</dd>
  <dt id="elevateprivileges=string"><a class="permalink" href="#elevateprivileges=string"><b><b>elevateprivileges=string</b></b></a></dt>
  <dd>Disable set*uid|gid system calls</dd>
  <dt id="spawn=string"><a class="permalink" href="#spawn=string"><b><b>spawn=string</b></b></a></dt>
  <dd>Disable *fork and execve</dd>
  <dt id="resourcecontrol=string"><a class="permalink" href="#resourcecontrol=string"><b><b>resourcecontrol=string</b></b></a></dt>
  <dd>Disable process affinity and schedular priority</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="readconfig"><a class="permalink" href="#readconfig"><b><b>-readconfig
    file</b></b></a></dt>
  <dd>Read device configuration from file. This approach is useful when you want
      to spawn QEMU process with many command line options but you don't want to
      exceed the command line character limit.</dd>
  <dt id="no~6"><a class="permalink" href="#no~6"><b><b>-no-user-config</b></b></a></dt>
  <dd>The <b>-no-user-config</b> option makes QEMU not load any of the
      user-provided config files on sysconfdir.</dd>
  <dt id="trace"><a class="permalink" href="#trace"><b><b>-trace
    [[enable=]pattern][,events=file][,file=file]</b></b></a></dt>
  <dd>Specify tracing options.
    <p class="Pp"><b>[enable=]PATTERN</b></p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">Immediately enable events matching <i>PATTERN</i> (either
  event name or a globbing pattern). This option is only available if QEMU has
  been compiled with the <b>simple</b>, <b>log</b> or <b>ftrace</b> tracing
  backend. To specify multiple events or patterns, specify the <b>-trace</b>
  option multiple times.
<p class="Pp">Use <b>-trace help</b> to print a list of names of trace
  points.</p>
</div>
<br/>
</div>
<br/>
<p class="Pp"><b>events=FILE</b></p>
<div class="Bd-indent">
<div class="Bd-indent">Immediately enable events listed in <i>FILE</i>. The file
  must contain one event name (as listed in the <b>trace-events-all</b> file)
  per line; globbing patterns are accepted too. This option is only available if
  QEMU has been compiled with the <b>simple</b>, <b>log</b> or <b>ftrace</b>
  tracing backend.</div>
<br/>
</div>
<br/>
<p class="Pp"><b>file=FILE</b></p>
<div class="Bd-indent">
<div class="Bd-indent">Log output traces to <i>FILE</i>. This option is only
  available if QEMU has been compiled with the <b>simple</b> tracing
  backend.</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="plugin"><a class="permalink" href="#plugin"><b><b>-plugin
    file=file[,argname=argvalue]</b></b></a></dt>
  <dd>Load a plugin.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="file=file~2"><a class="permalink" href="#file=file~2"><b><b>file=file</b></b></a></dt>
  <dd>Load the given plugin from a shared library file.</dd>
  <dt id="argname=argvalue"><a class="permalink" href="#argname=argvalue"><b><b>argname=argvalue</b></b></a></dt>
  <dd>Argument passed to the plugin. (Can be given multiple times.)</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="enable~2"><a class="permalink" href="#enable~2"><b><b>-enable-fips</b></b></a></dt>
  <dd>Enable FIPS 140-2 compliance mode.</dd>
  <dt id="msg"><a class="permalink" href="#msg"><b><b>-msg
    [timestamp[=on|off]][,guest-name[=on|off]]</b></b></a></dt>
  <dd>Control error message format.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="timestamp=on_off"><a class="permalink" href="#timestamp=on_off"><b><b>timestamp=on|off</b></b></a></dt>
  <dd>Prefix messages with a timestamp. Default is off.</dd>
  <dt id="guest"><a class="permalink" href="#guest"><b><b>guest-name=on|off</b></b></a></dt>
  <dd>Prefix messages with guest name but only if -name guest option is set
      otherwise the option is ignored. Default is off.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="dump~2"><a class="permalink" href="#dump~2"><b><b>-dump-vmstate
    file</b></b></a></dt>
  <dd>Dump json-encoded vmstate information for current machine type to file in
      file</dd>
  <dt id="enable~3"><a class="permalink" href="#enable~3"><b><b>-enable-sync-profile</b></b></a></dt>
  <dd>Enable synchronization profiling.</dd>
</dl>
</div>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Generic_object_creation"><a class="permalink" href="#Generic_object_creation">Generic
  object creation</a></h2>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="object"><a class="permalink" href="#object"><b><b>-object
    typename[,prop1=value1,...]</b></b></a></dt>
  <dd>Create a new object of type typename setting properties in the order they
      are specified. Note that the 'id' property must be set. These objects are
      placed in the '/objects' path.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="object~2"><a class="permalink" href="#object~2"><b><b>-object
    memory-backend-file,id=id,size=size,mem-path=dir,share=on|off,discard-data=on|off,merge=on|off,dump=on|off,prealloc=on|off,host-nodes=host-nodes,policy=default|preferred|bind|interleave,align=align,readonly=on|off</b></b></a></dt>
  <dd>Creates a memory file backend object, which can be used to back the guest
      RAM with huge pages.
    <p class="Pp">The <b>id</b> parameter is a unique ID that will be used to
        reference this memory region in other parameters, e.g. <b>-numa</b>,
        <b>-device nvdimm</b>, etc.</p>
    <p class="Pp">The <b>size</b> option provides the size of the memory region,
        and accepts common suffixes, e.g. <b>500M</b>.</p>
    <p class="Pp">The <b>mem-path</b> provides the path to either a shared
        memory or huge page filesystem mount.</p>
    <p class="Pp">The <b>share</b> boolean option determines whether the memory
        region is marked as private to QEMU, or shared. The latter allows a
        co-operating external process to access the QEMU memory region.</p>
    <p class="Pp">The <b>share</b> is also required for pvrdma devices due to
        limitations in the RDMA API provided by Linux.</p>
    <p class="Pp">Setting share=on might affect the ability to configure NUMA
        bindings for the memory backend under some circumstances, see
        Documentation/vm/numa_memory_policy.txt on the Linux kernel source tree
        for additional details.</p>
    <p class="Pp">Setting the <b>discard-data</b> boolean option to on indicates
        that file contents can be destroyed when QEMU exits, to avoid
        unnecessarily flushing data to the backing file. Note that
        <b>discard-data</b> is only an optimization, and QEMU might not discard
        file contents if it aborts unexpectedly or is terminated using
      SIGKILL.</p>
    <p class="Pp">The <b>merge</b> boolean option enables memory merge, also
        known as MADV_MERGEABLE, so that Kernel Samepage Merging will consider
        the pages for memory deduplication.</p>
    <p class="Pp">Setting the <b>dump</b> boolean option to off excludes the
        memory from core dumps. This feature is also known as MADV_DONTDUMP.</p>
    <p class="Pp">The <b>prealloc</b> boolean option enables memory
        preallocation.</p>
    <p class="Pp">The <b>host-nodes</b> option binds the memory range to a list
        of NUMA host nodes.</p>
    <p class="Pp">The <b>policy</b> option sets the NUMA policy to one of the
        following values:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="default"><a class="permalink" href="#default"><b><b>default</b></b></a></dt>
  <dd>default host policy</dd>
  <dt id="preferred"><a class="permalink" href="#preferred"><b><b>preferred</b></b></a></dt>
  <dd>prefer the given host node list for allocation</dd>
  <dt id="bind"><a class="permalink" href="#bind"><b><b>bind</b></b></a></dt>
  <dd>restrict memory allocation to the given host node list</dd>
  <dt id="interleave"><a class="permalink" href="#interleave"><b><b>interleave</b></b></a></dt>
  <dd>interleave memory allocations across the given host node list</dd>
</dl>
</div>
<br/>
<p class="Pp">The <b>align</b> option specifies the base address alignment when
    QEMU mmap(2) <b>mem-path</b>, and accepts common suffixes, eg <b>2M</b>.
    Some backend store specified by <b>mem-path</b> requires an alignment
    different than the default one used by QEMU, eg the device DAX /dev/dax0.0
    requires 2M alignment rather than 4K. In such cases, users can specify the
    required alignment via this option.</p>
<p class="Pp">The <b>pmem</b> option specifies whether the backing file
    specified by <b>mem-path</b> is in host persistent memory that can be
    accessed using the SNIA NVM programming model (e.g. Intel NVDIMM). If
    <b>pmem</b> is set to 'on', QEMU will take necessary operations to guarantee
    the persistence of its own writes to <b>mem-path</b> (e.g. in vNVDIMM label
    emulation and live migration). Also, we will map the backend-file with
    MAP_SYNC flag, which ensures the file metadata is in sync for
    <b>mem-path</b> in case of host crash or a power failure. MAP_SYNC requires
    support from both the host kernel (since Linux kernel 4.15) and the
    filesystem of <b>mem-path</b> mounted with DAX option.</p>
<p class="Pp">The <b>readonly</b> option specifies whether the backing file is
    opened read-only or read-write (default).</p>
<dl class="Bl-tag">
  <dt id="object~3"><a class="permalink" href="#object~3"><b><b>-object
    memory-backend-ram,id=id,merge=on|off,dump=on|off,share=on|off,prealloc=on|off,size=size,host-nodes=host-nodes,policy=default|preferred|bind|interleave</b></b></a></dt>
  <dd>Creates a memory backend object, which can be used to back the guest RAM.
      Memory backend objects offer more control than the <b>-m</b> option that
      is traditionally used to define guest RAM. Please refer to
      <b>memory-backend-file</b> for a description of the options.</dd>
  <dt id="object~4"><a class="permalink" href="#object~4"><b><b>-object
    memory-backend-memfd,id=id,merge=on|off,dump=on|off,share=on|off,prealloc=on|off,size=size,host-nodes=host-nodes,policy=default|preferred|bind|interleave,seal=on|off,hugetlb=on|off,hugetlbsize=size</b></b></a></dt>
  <dd>Creates an anonymous memory file backend object, which allows QEMU to
      share the memory with an external process (e.g. when using vhost-user).
      The memory is allocated with memfd and optional sealing. (Linux only)
    <p class="Pp">The <b>seal</b> option creates a sealed-file, that will block
        further resizing the memory ('on' by default).</p>
    <p class="Pp">The <b>hugetlb</b> option specify the file to be created
        resides in the hugetlbfs filesystem (since Linux 4.14). Used in
        conjunction with the <b>hugetlb</b> option, the <b>hugetlbsize</b>
        option specify the hugetlb page size on systems that support multiple
        hugetlb page sizes (it must be a power of 2 value supported by the
        system).</p>
    <p class="Pp">In some versions of Linux, the <b>hugetlb</b> option is
        incompatible with the <b>seal</b> option (requires at least Linux
      4.16).</p>
    <p class="Pp">Please refer to <b>memory-backend-file</b> for a description
        of the other options.</p>
    <p class="Pp">The <b>share</b> boolean option is on by default with
      memfd.</p>
  </dd>
  <dt id="object~5"><a class="permalink" href="#object~5"><b><b>-object
    rng-builtin,id=id</b></b></a></dt>
  <dd>Creates a random number generator backend which obtains entropy from QEMU
      builtin functions. The <b>id</b> parameter is a unique ID that will be
      used to reference this entropy backend from the <b>virtio-rng</b> device.
      By default, the <b>virtio-rng</b> device uses this RNG backend.</dd>
  <dt id="object~6"><a class="permalink" href="#object~6"><b><b>-object
    rng-random,id=id,filename=/dev/random</b></b></a></dt>
  <dd>Creates a random number generator backend which obtains entropy from a
      device on the host. The <b>id</b> parameter is a unique ID that will be
      used to reference this entropy backend from the <b>virtio-rng</b> device.
      The <b>filename</b> parameter specifies which file to obtain entropy from
      and if omitted defaults to <b>/dev/urandom</b>.</dd>
  <dt id="object~7"><a class="permalink" href="#object~7"><b><b>-object
    rng-egd,id=id,chardev=chardevid</b></b></a></dt>
  <dd>Creates a random number generator backend which obtains entropy from an
      external daemon running on the host. The <b>id</b> parameter is a unique
      ID that will be used to reference this entropy backend from the
      <b>virtio-rng</b> device. The <b>chardev</b> parameter is the unique ID of
      a character device backend that provides the connection to the RNG
    daemon.</dd>
  <dt id="object~8"><a class="permalink" href="#object~8"><b><b>-object
    tls-creds-anon,id=id,endpoint=endpoint,dir=/path/to/cred/dir,verify-peer=on|off</b></b></a></dt>
  <dd>Creates a TLS anonymous credentials object, which can be used to provide
      TLS support on network backends. The <b>id</b> parameter is a unique ID
      which network backends will use to access the credentials. The
      <b>endpoint</b> is either <b>server</b> or <b>client</b> depending on
      whether the QEMU network backend that uses the credentials will be acting
      as a client or as a server. If <b>verify-peer</b> is enabled (the default)
      then once the handshake is completed, the peer credentials will be
      verified, though this is a no-op for anonymous credentials.
    <p class="Pp">The dir parameter tells QEMU where to find the credential
        files. For server endpoints, this directory may contain a file
        dh-params.pem providing diffie-hellman parameters to use for the TLS
        server. If the file is missing, QEMU will generate a set of DH
        parameters at startup. This is a computationally expensive operation
        that consumes random pool entropy, so it is recommended that a
        persistent set of parameters be generated upfront and saved.</p>
  </dd>
  <dt id="object~9"><a class="permalink" href="#object~9"><b><b>-object
    tls-creds-psk,id=id,endpoint=endpoint,dir=/path/to/keys/dir[,username=username]</b></b></a></dt>
  <dd>Creates a TLS Pre-Shared Keys (PSK) credentials object, which can be used
      to provide TLS support on network backends. The <b>id</b> parameter is a
      unique ID which network backends will use to access the credentials. The
      <b>endpoint</b> is either <b>server</b> or <b>client</b> depending on
      whether the QEMU network backend that uses the credentials will be acting
      as a client or as a server. For clients only, <b>username</b> is the
      username which will be sent to the server. If omitted it defaults to
      &quot;qemu&quot;.
    <p class="Pp">The dir parameter tells QEMU where to find the keys file. It
        is called &quot;dir/keys.psk&quot; and contains &quot;username:key&quot;
        pairs. This file can most easily be created using the GnuTLS
        <b>psktool</b> program.</p>
    <p class="Pp">For server endpoints, dir may also contain a file
        dh-params.pem providing diffie-hellman parameters to use for the TLS
        server. If the file is missing, QEMU will generate a set of DH
        parameters at startup. This is a computationally expensive operation
        that consumes random pool entropy, so it is recommended that a
        persistent set of parameters be generated up front and saved.</p>
  </dd>
  <dt id="object~10"><a class="permalink" href="#object~10"><b><b>-object
    tls-creds-x509,id=id,endpoint=endpoint,dir=/path/to/cred/dir,priority=priority,verify-peer=on|off,passwordid=id</b></b></a></dt>
  <dd>Creates a TLS anonymous credentials object, which can be used to provide
      TLS support on network backends. The <b>id</b> parameter is a unique ID
      which network backends will use to access the credentials. The
      <b>endpoint</b> is either <b>server</b> or <b>client</b> depending on
      whether the QEMU network backend that uses the credentials will be acting
      as a client or as a server. If <b>verify-peer</b> is enabled (the default)
      then once the handshake is completed, the peer credentials will be
      verified. With x509 certificates, this implies that the clients must be
      provided with valid client certificates too.
    <p class="Pp">The dir parameter tells QEMU where to find the credential
        files. For server endpoints, this directory may contain a file
        dh-params.pem providing diffie-hellman parameters to use for the TLS
        server. If the file is missing, QEMU will generate a set of DH
        parameters at startup. This is a computationally expensive operation
        that consumes random pool entropy, so it is recommended that a
        persistent set of parameters be generated upfront and saved.</p>
    <p class="Pp">For x509 certificate credentials the directory will contain
        further files providing the x509 certificates. The certificates must be
        stored in PEM format, in filenames ca-cert.pem, ca-crl.pem (optional),
        server-cert.pem (only servers), server-key.pem (only servers),
        client-cert.pem (only clients), and client-key.pem (only clients).</p>
    <p class="Pp">For the server-key.pem and client-key.pem files which contain
        sensitive private keys, it is possible to use an encrypted version by
        providing the passwordid parameter. This provides the ID of a previously
        created <b>secret</b> object containing the password for decryption.</p>
    <p class="Pp">The priority parameter allows to override the global default
        priority used by gnutls. This can be useful if the system administrator
        needs to use a weaker set of crypto priorities for QEMU without
        potentially forcing the weakness onto all applications. Or conversely if
        one wants wants a stronger default for QEMU than for all other
        applications, they can do this through this parameter. Its format is a
        gnutls priority string as described at
        <i>https://gnutls.org/manual/html_node/Priority-Strings.html</i>.</p>
  </dd>
  <dt id="object~11"><a class="permalink" href="#object~11"><b><b>-object
    tls-cipher-suites,id=id,priority=priority</b></b></a></dt>
  <dd>Creates a TLS cipher suites object, which can be used to control the TLS
      cipher/protocol algorithms that applications are permitted to use.
    <p class="Pp">The <b>id</b> parameter is a unique ID which frontends will
        use to access the ordered list of permitted TLS cipher suites from the
        host.</p>
    <p class="Pp">The <b>priority</b> parameter allows to override the global
        default priority used by gnutls. This can be useful if the system
        administrator needs to use a weaker set of crypto priorities for QEMU
        without potentially forcing the weakness onto all applications. Or
        conversely if one wants wants a stronger default for QEMU than for all
        other applications, they can do this through this parameter. Its format
        is a gnutls priority string as described at
        <i>https://gnutls.org/manual/html_node/Priority-Strings.html</i>.</p>
    <p class="Pp">An example of use of this object is to control UEFI HTTPS
        Boot. The tls-cipher-suites object exposes the ordered list of permitted
        TLS cipher suites from the host side to the guest firmware, via fw_cfg.
        The list is represented as an array of IANA_TLS_CIPHER objects. The
        firmware uses the IANA_TLS_CIPHER array for configuring guest-side
      TLS.</p>
    <p class="Pp">In the following example, the priority at which the host-side
        policy is retrieved is given by the <b>priority</b> property. Given that
        QEMU uses GNUTLS, <b>priority=@SYSTEM</b> may be used to refer to
        /etc/crypto-policies/back-ends/gnutls.config.</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># qemu-system-x86_64 \
<br/>
    -object tls-cipher-suites,id=mysuite0,priority=@SYSTEM \
<br/>
    -fw_cfg name=etc/edk2/https/ciphers,gen_id=mysuite0
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="object~12"><a class="permalink" href="#object~12"><b><b>-object
    filter-buffer,id=id,netdev=netdevid,interval=t[,queue=all|rx|tx][,status=on|off][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]</b></b></a></dt>
  <dd>Interval t can't be 0, this filter batches the packet delivery: all
      packets arriving in a given interval on netdev netdevid are delayed until
      the end of the interval. Interval is in microseconds. <b>status</b> is
      optional that indicate whether the netfilter is on (enabled) or off
      (disabled), the default status for netfilter will be 'on'.
    <p class="Pp">queue all|rx|tx is an option that can be applied to any
        netfilter.</p>
    <p class="Pp"><b>all</b>: the filter is attached both to the receive and the
        transmit queue of the netdev (default).</p>
    <p class="Pp"><b>rx</b>: the filter is attached to the receive queue of the
        netdev, where it will receive packets sent to the netdev.</p>
    <p class="Pp"><b>tx</b>: the filter is attached to the transmit queue of the
        netdev, where it will receive packets sent by the netdev.</p>
    <p class="Pp">position head|tail|id=&lt;id&gt; is an option to specify where
        the filter should be inserted in the filter list. It can be applied to
        any netfilter.</p>
    <p class="Pp"><b>head</b>: the filter is inserted at the head of the filter
        list, before any existing filters.</p>
    <p class="Pp"><b>tail</b>: the filter is inserted at the tail of the filter
        list, behind any existing filters (default).</p>
    <p class="Pp"><b>id=&lt;id&gt;</b>: the filter is inserted before or behind
        the filter specified by &lt;id&gt;, see the insert option below.</p>
    <p class="Pp">insert behind|before is an option to specify where to insert
        the new filter relative to the one specified with
        position=id=&lt;id&gt;. It can be applied to any netfilter.</p>
    <p class="Pp"><b>before</b>: insert before the specified filter.</p>
    <p class="Pp"><b>behind</b>: insert behind the specified filter
      (default).</p>
  </dd>
  <dt id="object~13"><a class="permalink" href="#object~13"><b><b>-object
    filter-mirror,id=id,netdev=netdevid,outdev=chardevid,queue=all|rx|tx[,vnet_hdr_support][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]</b></b></a></dt>
  <dd>filter-mirror on netdev netdevid,mirror net packet to chardevchardevid, if
      it has the vnet_hdr_support flag, filter-mirror will mirror packet with
      vnet_hdr_len.</dd>
  <dt id="object~14"><a class="permalink" href="#object~14"><b><b>-object
    filter-redirector,id=id,netdev=netdevid,indev=chardevid,outdev=chardevid,queue=all|rx|tx[,vnet_hdr_support][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]</b></b></a></dt>
  <dd>filter-redirector on netdev netdevid,redirect filter's net packet to
      chardev chardevid,and redirect indev's packet to filter.if it has the
      vnet_hdr_support flag, filter-redirector will redirect packet with
      vnet_hdr_len. Create a filter-redirector we need to differ outdev id from
      indev id, id can not be the same. we can just use indev or outdev, but at
      least one of indev or outdev need to be specified.</dd>
  <dt id="object~15"><a class="permalink" href="#object~15"><b><b>-object
    filter-rewriter,id=id,netdev=netdevid,queue=all|rx|tx,[vnet_hdr_support][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]</b></b></a></dt>
  <dd>Filter-rewriter is a part of COLO project.It will rewrite tcp packet to
      secondary from primary to keep secondary tcp connection,and rewrite tcp
      packet to primary from secondary make tcp packet can be handled by
      client.if it has the vnet_hdr_support flag, we can parse packet with vnet
      header.
    <p class="Pp">usage: colo secondary: -object
        filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0 -object
        filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1 -object
        filter-rewriter,id=rew0,netdev=hn0,queue=all</p>
  </dd>
  <dt id="object~16"><a class="permalink" href="#object~16"><b><b>-object
    filter-dump,id=id,netdev=dev[,file=filename][,maxlen=len][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]</b></b></a></dt>
  <dd>Dump the network traffic on netdev dev to the file specified by filename.
      At most len bytes (64k by default) per packet are stored. The file format
      is libpcap, so it can be analyzed with tools such as tcpdump or
    Wireshark.</dd>
  <dt id="object~17"><a class="permalink" href="#object~17"><b><b>-object
    colo-compare,id=id,primary_in=chardevid,secondary_in=chardevid,outdev=chardevid,iothread=id[,vnet_hdr_support][,notify_dev=id][,compare_timeout=@var{ms}][,expired_scan_cycle=@var{ms}][,max_queue_size=@var{size}]</b></b></a></dt>
  <dd>Colo-compare gets packet from primary_in chardevid and secondary_in, then
      compare whether the payload of primary packet and secondary packet are the
      same. If same, it will output primary packet to out_dev, else it will
      notify COLO-framework to do checkpoint and send primary packet to out_dev.
      In order to improve efficiency, we need to put the task of comparison in
      another iothread. If it has the vnet_hdr_support flag, colo compare will
      send/recv packet with vnet_hdr_len. The <i>compare_timeout=@var{ms</i>}
      determines the maximum time of the colo-compare hold the packet. The
      <i>expired_scan_cycle=@var{ms</i>} is to set the period of scanning
      expired primary node network packets. The <i>max_queue_size=@var{size</i>}
      is to set the max compare queue size depend on user environment. If user
      want to use Xen COLO, need to add the notify_dev to notify Xen colo-frame
      to do checkpoint.
    <p class="Pp">COLO-compare must be used with the help of filter-mirror,
        filter-redirector and filter-rewriter.</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>KVM COLO
primary:
-netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown
-device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66
-chardev socket,id=mirror0,host=3.3.3.3,port=9003,server=on,wait=off
-chardev socket,id=compare1,host=3.3.3.3,port=9004,server=on,wait=off
-chardev socket,id=compare0,host=3.3.3.3,port=9001,server=on,wait=off
-chardev socket,id=compare0-0,host=3.3.3.3,port=9001
-chardev socket,id=compare_out,host=3.3.3.3,port=9005,server=on,wait=off
-chardev socket,id=compare_out0,host=3.3.3.3,port=9005
-object iothread,id=iothread1
-object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0
-object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out
-object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0
-object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0,iothread=iothread1
secondary:
-netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,down script=/etc/qemu-ifdown
-device e1000,netdev=hn0,mac=52:a4:00:12:78:66
-chardev socket,id=red0,host=3.3.3.3,port=9003
-chardev socket,id=red1,host=3.3.3.3,port=9004
-object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0
-object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1
Xen COLO
primary:
-netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown
-device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66
-chardev socket,id=mirror0,host=3.3.3.3,port=9003,server=on,wait=off
-chardev socket,id=compare1,host=3.3.3.3,port=9004,server=on,wait=off
-chardev socket,id=compare0,host=3.3.3.3,port=9001,server=on,wait=off
-chardev socket,id=compare0-0,host=3.3.3.3,port=9001
-chardev socket,id=compare_out,host=3.3.3.3,port=9005,server=on,wait=off
-chardev socket,id=compare_out0,host=3.3.3.3,port=9005
-chardev socket,id=notify_way,host=3.3.3.3,port=9009,server=on,wait=off
-object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0
-object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out
-object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0
-object iothread,id=iothread1
-object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0,notify_dev=nofity_way,iothread=iothread1
secondary:
-netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,down script=/etc/qemu-ifdown
-device e1000,netdev=hn0,mac=52:a4:00:12:78:66
-chardev socket,id=red0,host=3.3.3.3,port=9003
-chardev socket,id=red1,host=3.3.3.3,port=9004
-object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0
-object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">If you want to know the detail of above command line, you can read
    the colo-compare git log.</p>
<dl class="Bl-tag">
  <dt id="object~18"><a class="permalink" href="#object~18"><b><b>-object
    cryptodev-backend-builtin,id=id[,queues=queues]</b></b></a></dt>
  <dd>Creates a cryptodev backend which executes crypto opreation from the QEMU
      cipher APIS. The id parameter is a unique ID that will be used to
      reference this cryptodev backend from the <b>virtio-crypto</b> device. The
      queues parameter is optional, which specify the queue number of cryptodev
      backend, the default of queues is 1.</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># qemu-system-x86_64 \
<br/>
  [...] \
<br/>
      -object cryptodev-backend-builtin,id=cryptodev0 \
<br/>
      -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \
<br/>
  [...]
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="object~19"><a class="permalink" href="#object~19"><b><b>-object
    cryptodev-vhost-user,id=id,chardev=chardevid[,queues=queues]</b></b></a></dt>
  <dd>Creates a vhost-user cryptodev backend, backed by a chardev chardevid. The
      id parameter is a unique ID that will be used to reference this cryptodev
      backend from the <b>virtio-crypto</b> device. The chardev should be a unix
      domain socket backed one. The vhost-user uses a specifically defined
      protocol to pass vhost ioctl replacement messages to an application on the
      other end of the socket. The queues parameter is optional, which specify
      the queue number of cryptodev backend for multiqueue vhost-user, the
      default of queues is 1.</dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># qemu-system-x86_64 \
<br/>
  [...] \
<br/>
      -chardev socket,id=chardev0,path=/path/to/socket \
<br/>
      -object cryptodev-vhost-user,id=cryptodev0,chardev=chardev0 \
<br/>
      -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \
<br/>
  [...]
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="object~20"><a class="permalink" href="#object~20"><b><b>-object
    secret,id=id,data=string,format=raw|base64[,keyid=secretid,iv=string]</b></b></a></dt>
  <dd>
    <p class="Pp"></p>
  </dd>
  <dt id="object~21"><a class="permalink" href="#object~21"><b><b>-object
    secret,id=id,file=filename,format=raw|base64[,keyid=secretid,iv=string]</b></b></a></dt>
  <dd>Defines a secret to store a password, encryption key, or some other
      sensitive data. The sensitive data can either be passed directly via the
      data parameter, or indirectly via the file parameter. Using the data
      parameter is insecure unless the sensitive data is encrypted.
    <p class="Pp">The sensitive data can be provided in raw format (the
        default), or base64. When encoded as JSON, the raw format only supports
        valid UTF-8 characters, so base64 is recommended for sending binary
        data. QEMU will convert from which ever format is provided to the format
        it needs internally. eg, an RBD password can be provided in raw format,
        even though it will be base64 encoded when passed onto the RBD
      sever.</p>
    <p class="Pp">For added protection, it is possible to encrypt the data
        associated with a secret using the AES-256-CBC cipher. Use of encryption
        is indicated by providing the keyid and iv parameters. The keyid
        parameter provides the ID of a previously defined secret that contains
        the AES-256 decryption key. This key should be 32-bytes long and be
        base64 encoded. The iv parameter provides the random initialization
        vector used for encryption of this particular secret and should be a
        base64 encrypted string of the 16-byte IV.</p>
    <p class="Pp">The simplest (insecure) usage is to provide the secret
      inline</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># qemu-system-x86_64 -object secret,id=sec0,data=letmein,format=raw
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">The simplest secure usage is to provide the secret via a file</p>
<p class="Pp"># printf &quot;letmein&quot; &gt; mypasswd.txt # QEMU_SYSTEM_MACRO
    -object secret,id=sec0,file=mypasswd.txt,format=raw</p>
<p class="Pp">For greater security, AES-256-CBC should be used. To illustrate
    usage, consider the openssl command line tool which can encrypt the data.
    Note that when encrypting, the plaintext must be padded to the cipher block
    size (32 bytes) using the standard PKCS#5/6 compatible padding
  algorithm.</p>
<p class="Pp">First a master key needs to be created in base64 encoding:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># openssl rand -base64 32 &gt; key.b64
# KEY=$(base64 -d key.b64 | hexdump  -v -e '/1 &quot;%02X&quot;')
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Each secret to be encrypted needs to have a random initialization
    vector generated. These do not need to be kept secret</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># openssl rand -base64 16 &gt; iv.b64
# IV=$(base64 -d iv.b64 | hexdump  -v -e '/1 &quot;%02X&quot;')
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">The secret to be defined can now be encrypted, in this case we're
    telling openssl to base64 encode the result, but it could be left as raw
    bytes if desired.</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># SECRET=$(printf &quot;letmein&quot; |
<br/>
           openssl enc -aes-256-cbc -a -K $KEY -iv $IV)
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">When launching QEMU, create a master secret pointing to
    <b>key.b64</b> and specify that to be used to decrypt the user password.
    Pass the contents of <b>iv.b64</b> to the second secret</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># qemu-system-x86_64 \
<br/>
    -object secret,id=secmaster0,format=base64,file=key.b64 \
<br/>
    -object secret,id=sec0,keyid=secmaster0,format=base64,\
<br/>
        data=$SECRET,iv=$(&lt;iv.b64)
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="object~22"><a class="permalink" href="#object~22"><b><b>-object
    sev-guest,id=id,cbitpos=cbitpos,reduced-phys-bits=val,[sev-device=string,policy=policy,handle=handle,dh-cert-file=file,session-file=file,kernel-hashes=on|off]</b></b></a></dt>
  <dd>Create a Secure Encrypted Virtualization (SEV) guest object, which can be
      used to provide the guest memory encryption support on AMD processors.
    <p class="Pp">When memory encryption is enabled, one of the physical address
        bit (aka the C-bit) is utilized to mark if a memory page is protected.
        The <b>cbitpos</b> is used to provide the C-bit position. The C-bit
        position is Host family dependent hence user must provide this value. On
        EPYC, the value should be 47.</p>
    <p class="Pp">When memory encryption is enabled, we loose certain bits in
        physical address space. The <b>reduced-phys-bits</b> is used to provide
        the number of bits we loose in physical address space. Similar to C-bit,
        the value is Host family dependent. On EPYC, the value should be 5.</p>
    <p class="Pp">The <b>sev-device</b> provides the device file to use for
        communicating with the SEV firmware running inside AMD Secure Processor.
        The default device is '/dev/sev'. If hardware supports memory encryption
        then /dev/sev devices are created by CCP driver.</p>
    <p class="Pp">The <b>policy</b> provides the guest policy to be enforced by
        the SEV firmware and restrict what configuration and operational
        commands can be performed on this guest by the hypervisor. The policy
        should be provided by the guest owner and is bound to the guest and
        cannot be changed throughout the lifetime of the guest. The default is
        0.</p>
    <p class="Pp">If guest <b>policy</b> allows sharing the key with another SEV
        guest then <b>handle</b> can be use to provide handle of the guest from
        which to share the key.</p>
    <p class="Pp">The <b>dh-cert-file</b> and <b>session-file</b> provides the
        guest owner's Public Diffie-Hillman key defined in SEV spec. The PDH and
        session parameters are used for establishing a cryptographic session
        with the guest owner to negotiate keys used for attestation. The file
        must be encoded in base64.</p>
    <p class="Pp">The <b>kernel-hashes</b> adds the hashes of given
        kernel/initrd/ cmdline to a designated guest firmware page for measured
        Linux boot with -kernel. The default is off. (Since 6.2)</p>
    <p class="Pp">e.g to launch a SEV guest</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># qemu-system-x86_64 \
<br/>
    ...... \
<br/>
    -object sev-guest,id=sev0,cbitpos=47,reduced-phys-bits=5 \
<br/>
    -machine ...,memory-encryption=sev0 \
<br/>
    .....
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="object~23"><a class="permalink" href="#object~23"><b><b>-object
    authz-simple,id=id,identity=string</b></b></a></dt>
  <dd>Create an authorization object that will control access to network
      services.
    <p class="Pp">The <b>identity</b> parameter is identifies the user and its
        format depends on the network service that authorization object is
        associated with. For authorizing based on TLS x509 certificates, the
        identity must be the x509 distinguished name. Note that care must be
        taken to escape any commas in the distinguished name.</p>
    <p class="Pp">An example authorization object to validate a x509
        distinguished name would look like:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># qemu-system-x86_64 \
<br/>
    ... \
<br/>
    -object 'authz-simple,id=auth0,identity=CN=laptop.example.com,,O=Example Org,,L=London,,ST=London,,C=GB' \
<br/>
    ...
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Note the use of quotes due to the x509 distinguished name
    containing whitespace, and escaping of ','.</p>
<dl class="Bl-tag">
  <dt id="object~24"><a class="permalink" href="#object~24"><b><b>-object
    authz-listfile,id=id,filename=path,refresh=on|off</b></b></a></dt>
  <dd>Create an authorization object that will control access to network
      services.
    <p class="Pp">The <b>filename</b> parameter is the fully qualified path to a
        file containing the access control list rules in JSON format.</p>
    <p class="Pp">An example set of rules that match against SASL usernames
        might look like:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>{
<br/>
  &quot;rules&quot;: [
<br/>
     { &quot;match&quot;: &quot;fred&quot;, &quot;policy&quot;: &quot;allow&quot;, &quot;format&quot;: &quot;exact&quot; },
<br/>
     { &quot;match&quot;: &quot;bob&quot;, &quot;policy&quot;: &quot;allow&quot;, &quot;format&quot;: &quot;exact&quot; },
<br/>
     { &quot;match&quot;: &quot;danb&quot;, &quot;policy&quot;: &quot;deny&quot;, &quot;format&quot;: &quot;glob&quot; },
<br/>
     { &quot;match&quot;: &quot;dan*&quot;, &quot;policy&quot;: &quot;allow&quot;, &quot;format&quot;: &quot;exact&quot; },
<br/>
  ],
<br/>
  &quot;policy&quot;: &quot;deny&quot;
}
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">When checking access the object will iterate over all the rules
    and the first rule to match will have its <b>policy</b> value returned as
    the result. If no rules match, then the default <b>policy</b> value is
    returned.</p>
<p class="Pp">The rules can either be an exact string match, or they can use the
    simple UNIX glob pattern matching to allow wildcards to be used.</p>
<p class="Pp">If <b>refresh</b> is set to true the file will be monitored and
    automatically reloaded whenever its content changes.</p>
<p class="Pp">As with the <b>authz-simple</b> object, the format of the identity
    strings being matched depends on the network service, but is usually a TLS
    x509 distinguished name, or a SASL username.</p>
<p class="Pp">An example authorization object to validate a SASL username would
    look like:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># qemu-system-x86_64 \
<br/>
    ... \
<br/>
    -object authz-simple,id=auth0,filename=/etc/qemu/vnc-sasl.acl,refresh=on \
<br/>
    ...
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="object~25"><a class="permalink" href="#object~25"><b><b>-object
    authz-pam,id=id,service=string</b></b></a></dt>
  <dd>Create an authorization object that will control access to network
      services.
    <p class="Pp">The <b>service</b> parameter provides the name of a PAM
        service to use for authorization. It requires that a file
        <b>/etc/pam.d/service</b> exist to provide the configuration for the
        <b>account</b> subsystem.</p>
    <p class="Pp">An example authorization object to validate a TLS x509
        distinguished name would look like:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># qemu-system-x86_64 \
<br/>
    ... \
<br/>
    -object authz-pam,id=auth0,service=qemu-vnc \
<br/>
    ...
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">There would then be a corresponding config file for PAM at
    <b>/etc/pam.d/qemu-vnc</b> that contains:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>account requisite  pam_listfile.so item=user sense=allow \
<br/>
           file=/etc/qemu/vnc.allow
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Finally the <b>/etc/qemu/vnc.allow</b> file would contain the list
    of x509 distingished names that are permitted access</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>CN=laptop.example.com,O=Example Home,L=London,ST=London,C=GB
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="object~26"><a class="permalink" href="#object~26"><b><b>-object
    iothread,id=id,poll-max-ns=poll-max-ns,poll-grow=poll-grow,poll-shrink=poll-shrink,aio-max-batch=aio-max-batch</b></b></a></dt>
  <dd>Creates a dedicated event loop thread that devices can be assigned to.
      This is known as an IOThread. By default device emulation happens in vCPU
      threads or the main event loop thread. This can become a scalability
      bottleneck. IOThreads allow device emulation and I/O to run on other host
      CPUs.
    <p class="Pp">The <b>id</b> parameter is a unique ID that will be used to
        reference this IOThread from <b>-device ...,iothread=id</b>. Multiple
        devices can be assigned to an IOThread. Note that not all devices
        support an <b>iothread</b> parameter.</p>
    <p class="Pp">The <b>query-iothreads</b> QMP command lists IOThreads and
        reports their thread IDs so that the user can configure host CPU
        pinning/affinity.</p>
    <p class="Pp">IOThreads use an adaptive polling algorithm to reduce event
        loop latency. Instead of entering a blocking system call to monitor file
        descriptors and then pay the cost of being woken up when an event
        occurs, the polling algorithm spins waiting for events for a short time.
        The algorithm's default parameters are suitable for many cases but can
        be adjusted based on knowledge of the workload and/or host device
        latency.</p>
    <p class="Pp">The <b>poll-max-ns</b> parameter is the maximum number of
        nanoseconds to busy wait for events. Polling can be disabled by setting
        this value to 0.</p>
    <p class="Pp">The <b>poll-grow</b> parameter is the multiplier used to
        increase the polling time when the algorithm detects it is missing
        events due to not polling long enough.</p>
    <p class="Pp">The <b>poll-shrink</b> parameter is the divisor used to
        decrease the polling time when the algorithm detects it is spending too
        long polling without encountering events.</p>
    <p class="Pp">The <b>aio-max-batch</b> parameter is the maximum number of
        requests in a batch for the AIO engine, 0 means that the engine will use
        its default.</p>
    <p class="Pp">The IOThread parameters can be modified at run-time using the
        <b>qom-set</b> command (where <b>iothread1</b> is the IOThread's
        <b>id</b>):</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>(qemu) qom-set /objects/iothread1 poll-max-ns 100000
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<p class="Pp">During the graphical emulation, you can use special key
    combinations to change modes. The default key mappings are shown below, but
    if you use <b>-alt-grab</b> then the modifier is Ctrl-Alt-Shift (instead of
    Ctrl-Alt) and if you use <b>-ctrl-grab</b> then the modifier is the right
    Ctrl key (instead of Ctrl-Alt):</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Ctrl"><a class="permalink" href="#Ctrl"><b>Ctrl-Alt-f</b></a></dt>
  <dd>Toggle full screen</dd>
  <dt id="Ctrl~2"><a class="permalink" href="#Ctrl~2"><b>Ctrl-Alt-+</b></a></dt>
  <dd>Enlarge the screen</dd>
  <dt id="Ctrl~3"><a class="permalink" href="#Ctrl~3"><b>Ctrl-Alt--</b></a></dt>
  <dd>Shrink the screen</dd>
  <dt id="Ctrl~4"><a class="permalink" href="#Ctrl~4"><b>Ctrl-Alt-u</b></a></dt>
  <dd>Restore the screen's un-scaled dimensions</dd>
  <dt id="Ctrl~5"><a class="permalink" href="#Ctrl~5"><b>Ctrl-Alt-n</b></a></dt>
  <dd>Switch to virtual console 'n'. Standard console mappings are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><i>1</i></b></dt>
  <dd>Target system display</dd>
  <dt><b><i>2</i></b></dt>
  <dd>Monitor</dd>
  <dt><b><i>3</i></b></dt>
  <dd>Serial port</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="Ctrl~6"><a class="permalink" href="#Ctrl~6"><b>Ctrl-Alt</b></a></dt>
  <dd>Toggle mouse and keyboard grab.</dd>
</dl>
</div>
<br/>
<p class="Pp">In the virtual consoles, you can use Ctrl-Up, Ctrl-Down,
    Ctrl-PageUp and Ctrl-PageDown to move in the back log.</p>
<p class="Pp">During emulation, if you are using a character backend multiplexer
    (which is the default if you are using <b>-nographic</b>) then several
    commands are available via an escape sequence. These key sequences all start
    with an escape character, which is Ctrl-a by default, but can be changed
    with <b>-echr</b>. The list below assumes you're using the default.</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Ctrl~7"><a class="permalink" href="#Ctrl~7"><b>Ctrl-a h</b></a></dt>
  <dd>Print this help</dd>
  <dt id="Ctrl~8"><a class="permalink" href="#Ctrl~8"><b>Ctrl-a x</b></a></dt>
  <dd>Exit emulator</dd>
  <dt id="Ctrl~9"><a class="permalink" href="#Ctrl~9"><b>Ctrl-a s</b></a></dt>
  <dd>Save disk data back to file (if -snapshot)</dd>
  <dt id="Ctrl~10"><a class="permalink" href="#Ctrl~10"><b>Ctrl-a t</b></a></dt>
  <dd>Toggle console timestamps</dd>
  <dt id="Ctrl~11"><a class="permalink" href="#Ctrl~11"><b>Ctrl-a b</b></a></dt>
  <dd>Send break (magic sysrq in Linux)</dd>
  <dt id="Ctrl~12"><a class="permalink" href="#Ctrl~12"><b>Ctrl-a c</b></a></dt>
  <dd>Rotate between the frontends connected to the multiplexer (usually this
      switches between the monitor and the console)</dd>
  <dt id="Ctrl~13"><a class="permalink" href="#Ctrl~13"><b>Ctrl-a
    Ctrl-a</b></a></dt>
  <dd>Send the escape character to the frontend</dd>
</dl>
</div>
<br/>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">In addition to using normal file images for the emulated storage
    devices, QEMU can also use networked resources such as iSCSI devices. These
    are specified using a special URL syntax.</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="iSCSI"><a class="permalink" href="#iSCSI"><b><b>iSCSI</b></b></a></dt>
  <dd>iSCSI support allows QEMU to access iSCSI resources directly and use as
      images for the guest storage. Both disk and cdrom images are supported.
    <p class="Pp">Syntax for specifying iSCSI LUNs is
        &quot;iscsi://&lt;target-ip&gt;[:&lt;port&gt;]/&lt;target-iqn&gt;/&lt;lun&gt;&quot;</p>
    <p class="Pp">By default qemu will use the iSCSI initiator-name
        'iqn.2008-11.org.linux-kvm[:&lt;name&gt;]' but this can also be set from
        the command line or a configuration file.</p>
    <p class="Pp">Since version QEMU 2.4 it is possible to specify a iSCSI
        request timeout to detect stalled requests and force a reestablishment
        of the session. The timeout is specified in seconds. The default is 0
        which means no timeout. Libiscsi 1.15.0 or greater is required for this
        feature.</p>
    <p class="Pp">Example (without authentication):</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -iscsi initiator-name=iqn.2001-04.com.example:my-initiator \
<br/>
                 -cdrom iscsi://192.0.2.1/iqn.2001-04.com.example/2 \
<br/>
                 -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example (CHAP username/password via URL):</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -drive file=iscsi:<i>//user%password@192.0.2.1/iqn.2001-04.com.example/1</i>
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example (CHAP username/password via environment variables):</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>LIBISCSI_CHAP_USERNAME=&quot;user&quot; \
LIBISCSI_CHAP_PASSWORD=&quot;password&quot; \
qemu-system-x86_64 -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="NBD"><a class="permalink" href="#NBD"><b><b>NBD</b></b></a></dt>
  <dd>QEMU supports NBD (Network Block Devices) both using TCP protocol as well
      as Unix Domain Sockets. With TCP, the default port is 10809.
    <p class="Pp">Syntax for specifying a NBD device using TCP, in preferred URI
        form:
        &quot;nbd://&lt;server-ip&gt;[:&lt;port&gt;]/[&lt;export&gt;]&quot;</p>
    <p class="Pp">Syntax for specifying a NBD device using Unix Domain Sockets;
        remember that '?' is a shell glob character and may need quoting:
        &quot;nbd+unix:///[&lt;export&gt;]?socket=&lt;domain-socket&gt;&quot;</p>
    <p class="Pp">Older syntax that is also recognized:
        &quot;nbd:&lt;server-ip&gt;:&lt;port&gt;[:exportname=&lt;export&gt;]&quot;</p>
    <p class="Pp">Syntax for specifying a NBD device using Unix Domain Sockets
        &quot;nbd:unix:&lt;domain-socket&gt;[:exportname=&lt;export&gt;]&quot;</p>
    <p class="Pp">Example for TCP</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 --drive file=nbd:192.0.2.1:30000
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example for Unix Domain Sockets</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 --drive file=nbd:unix:/tmp/nbd-socket
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt id="SSH"><a class="permalink" href="#SSH"><b><b>SSH</b></b></a></dt>
  <dd>QEMU supports SSH (Secure Shell) access to remote disks.
    <p class="Pp">Examples:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 -drive file=ssh:<i>//user@host/path/to/disk.img</i>
qemu-system-x86_64 -drive file.driver=ssh,file.user=user,file.host=host,file.port=22,file.path=/path/to/disk.img
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Currently authentication must be done using ssh-agent. Other
    authentication methods may be supported in future.</p>
<dl class="Bl-tag">
  <dt id="GlusterFS"><a class="permalink" href="#GlusterFS"><b><b>GlusterFS</b></b></a></dt>
  <dd>GlusterFS is a user space distributed file system. QEMU supports the use
      of GlusterFS volumes for hosting VM disk images using TCP, Unix Domain
      Sockets and RDMA transport protocols.
    <p class="Pp">Syntax for specifying a VM disk image on GlusterFS volume
      is</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>URI:
gluster[+type]://[host[:port]]/volume/path[?socket=...][,debug=N][,logfile=...]
JSON:
'json:{&quot;driver&quot;:&quot;qcow2&quot;,&quot;file&quot;:{&quot;driver&quot;:&quot;gluster&quot;,&quot;volume&quot;:&quot;testvol&quot;,&quot;path&quot;:&quot;a.img&quot;,&quot;debug&quot;:N,&quot;logfile&quot;:&quot;...&quot;,
&#x00A0;                                &quot;server&quot;:[{&quot;type&quot;:&quot;tcp&quot;,&quot;host&quot;:&quot;...&quot;,&quot;port&quot;:&quot;...&quot;},
&#x00A0;                                          {&quot;type&quot;:&quot;unix&quot;,&quot;socket&quot;:&quot;...&quot;}]}}'
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>URI:
qemu-system-x86_64 --drive file=gluster://192.0.2.1/testvol/a.img,
&#x00A0;                              file.debug=9,file.logfile=/var/log/qemu-gluster.log
JSON:
qemu-system-x86_64 'json:{&quot;driver&quot;:&quot;qcow2&quot;,
&#x00A0;                         &quot;file&quot;:{&quot;driver&quot;:&quot;gluster&quot;,
&#x00A0;                                  &quot;volume&quot;:&quot;testvol&quot;,&quot;path&quot;:&quot;a.img&quot;,
&#x00A0;                                  &quot;debug&quot;:9,&quot;logfile&quot;:&quot;/var/log/qemu-gluster.log&quot;,
&#x00A0;                                  &quot;server&quot;:[{&quot;type&quot;:&quot;tcp&quot;,&quot;host&quot;:&quot;1.2.3.4&quot;,&quot;port&quot;:24007},
&#x00A0;                                            {&quot;type&quot;:&quot;unix&quot;,&quot;socket&quot;:&quot;/var/run/glusterd.socket&quot;}]}}'
qemu-system-x86_64 -drive driver=qcow2,file.driver=gluster,file.volume=testvol,file.path=/path/a.img,
&#x00A0;                                     file.debug=9,file.logfile=/var/log/qemu-gluster.log,
&#x00A0;                                     file.server.0.type=tcp,file.server.0.host=1.2.3.4,file.server.0.port=24007,
&#x00A0;                                     file.server.1.type=unix,file.server.1.socket=/var/run/glusterd.socket
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">See also <i>http://www.gluster.org</i>.</p>
<dl class="Bl-tag">
  <dt id="HTTP/HTTPS/FTP/FTPS"><a class="permalink" href="#HTTP/HTTPS/FTP/FTPS"><b><b>HTTP/HTTPS/FTP/FTPS</b></b></a></dt>
  <dd>QEMU supports read-only access to files accessed over http(s) and ftp(s).
    <p class="Pp">Syntax using a single filename:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>&lt;protocol&gt;://[&lt;username&gt;[:&lt;password&gt;]@]&lt;host&gt;/&lt;path&gt;
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">where:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="protocol"><a class="permalink" href="#protocol"><b><b>protocol</b></b></a></dt>
  <dd>'http', 'https', 'ftp', or 'ftps'.</dd>
  <dt id="username"><a class="permalink" href="#username"><b><b>username</b></b></a></dt>
  <dd>Optional username for authentication to the remote server.</dd>
  <dt id="password~3"><a class="permalink" href="#password~3"><b><b>password</b></b></a></dt>
  <dd>Optional password for authentication to the remote server.</dd>
  <dt id="host"><a class="permalink" href="#host"><b><b>host</b></b></a></dt>
  <dd>Address of the remote server.</dd>
  <dt id="path"><a class="permalink" href="#path"><b><b>path</b></b></a></dt>
  <dd>Path on the remote server, including any query string.</dd>
</dl>
</div>
<br/>
<p class="Pp">The following options are also supported:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="url"><a class="permalink" href="#url"><b><b>url</b></b></a></dt>
  <dd>The full URL when passing options to the driver explicitly.</dd>
  <dt id="readahead"><a class="permalink" href="#readahead"><b><b>readahead</b></b></a></dt>
  <dd>The amount of data to read ahead with each range request to the remote
      server. This value may optionally have the suffix 'T', 'G', 'M', 'K', 'k'
      or 'b'. If it does not have a suffix, it will be assumed to be in bytes.
      The value must be a multiple of 512 bytes. It defaults to 256k.</dd>
  <dt id="sslverify"><a class="permalink" href="#sslverify"><b><b>sslverify</b></b></a></dt>
  <dd>Whether to verify the remote server's certificate when connecting over
      SSL. It can have the value 'on' or 'off'. It defaults to 'on'.</dd>
  <dt id="cookie"><a class="permalink" href="#cookie"><b><b>cookie</b></b></a></dt>
  <dd>Send this cookie (it can also be a list of cookies separated by ';') with
      each outgoing request. Only supported when using protocols such as HTTP
      which support cookies, otherwise ignored.</dd>
  <dt id="timeout"><a class="permalink" href="#timeout"><b><b>timeout</b></b></a></dt>
  <dd>Set the timeout in seconds of the CURL connection. This timeout is the
      time that CURL waits for a response from the remote server to get the size
      of the image to be downloaded. If not set, the default timeout of 5
      seconds is used.</dd>
</dl>
</div>
<br/>
<p class="Pp">Note that when passing options to qemu explicitly, <b>driver</b>
    is the value of &lt;protocol&gt;.</p>
<p class="Pp">Example: boot from a remote Fedora 20 live ISO image</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-system-x86_64 --drive media=cdrom,file=https://archives.fedoraproject.org/pub/archive/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly
qemu-system-x86_64 --drive media=cdrom,file.driver=http,file.url=http://archives.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example: boot from a remote Fedora 20 cloud image using a local
    overlay for writes, copy-on-read, and a readahead of 64k</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-img create -f qcow2 -o backing_file='json:{&quot;file.driver&quot;:&quot;http&quot;,, &quot;file.url&quot;:&quot;<i>http://archives.fedoraproject.org/pub/archive/fedora/linux/releases/20/Images/x86_64/Fedora-x86_64-20-20131211.1-sda.qcow2</i>&quot;,, &quot;file.readahead&quot;:&quot;64k&quot;}' /tmp/Fedora-x86_64-20-20131211.1-sda.qcow2
qemu-system-x86_64 -drive file=/tmp/Fedora-x86_64-20-20131211.1-sda.qcow2,copy-on-read=on
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Example: boot from an image stored on a VMware vSphere server with
    a self-signed certificate using a local overlay for writes, a readahead of
    64k and a timeout of 10 seconds.</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>qemu-img create -f qcow2 -o backing_file='json:{&quot;file.driver&quot;:&quot;https&quot;,, &quot;file.url&quot;:&quot;<i>https://user:password@vsphere.example.com/folder/test/test-flat.vmdk?dcPath=Datacenter&amp;dsName=datastore1</i>&quot;,, &quot;file.sslverify&quot;:&quot;off&quot;,, &quot;file.readahead&quot;:&quot;64k&quot;,, &quot;file.timeout&quot;:10}' /tmp/test.qcow2
qemu-system-x86_64 -drive file=/tmp/test.qcow2
</pre>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The HTML documentation of QEMU for more precise information and
    Linux user mode emulator invocation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Fabrice Bellard</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">2022, The QEMU Project Developers</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">April 22, 2022</td>
    <td class="foot-os">7.0.0</td>
  </tr>
</table>
</body>
</html>
