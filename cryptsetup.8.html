<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   t
       Title: cryptsetup
      Author: [see the "AUTHOR(S)" section]
   Generator: Asciidoctor 2.0.18
        Date: 2023-02-09
      Manual: Maintenance Commands
      Source: cryptsetup 2.6.1
    Language: English
   -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="mandoc.css" type="text/css" media="all"/>
  <title>CRYPTSETUP(8)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CRYPTSETUP(8)</td>
    <td class="head-vol">Maintenance Commands</td>
    <td class="head-rtitle">CRYPTSETUP(8)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">cryptsetup - manage plain dm-crypt, LUKS, and other encrypted
    volumes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><b>cryptsetup &lt;action&gt; [&lt;options&gt;] &lt;action
    args&gt;</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">cryptsetup is used to conveniently setup dm-crypt managed
    device-mapper mappings. These include plain dm-crypt volumes and LUKS
    volumes. The difference is that LUKS uses a metadata header and can hence
    offer more features than plain dm-crypt. On the other hand, the header is
    visible and vulnerable to damage.</p>
<p class="Pp">In addition, cryptsetup provides limited support for the use of
    loop-AES volumes, TrueCrypt, VeraCrypt, BitLocker and FileVault2 compatible
    volumes.</p>
<p class="Pp">For more information about specific cryptsetup action see
    <b>cryptsetup-&lt;action&gt;</b>(8), where <b>&lt;action&gt;</b> is the name
    of the cryptsetup action.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BASIC_ACTIONS"><a class="permalink" href="#BASIC_ACTIONS">BASIC
  ACTIONS</a></h1>
<p class="Pp">The following are valid actions for all supported device
  types.</p>
<section class="Ss">
<h2 class="Ss" id="OPEN"><a class="permalink" href="#OPEN">OPEN</a></h2>
<p class="Pp"><b>open &lt;device&gt; &lt;name&gt; --type
  &lt;device_type&gt;</b></p>
<p class="Pp">Opens (creates a mapping with) &lt;name&gt; backed by device
    &lt;device&gt;.
  <br/>
  See <b>cryptsetup-open</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CLOSE"><a class="permalink" href="#CLOSE">CLOSE</a></h2>
<p class="Pp"><b>close &lt;name&gt;</b></p>
<p class="Pp">Removes the existing mapping &lt;name&gt; and wipes the key from
    kernel memory.
  <br/>
  See <b>cryptsetup-close</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="STATUS"><a class="permalink" href="#STATUS">STATUS</a></h2>
<p class="Pp"><b>status &lt;name&gt;</b></p>
<p class="Pp">Reports the status for the mapping &lt;name&gt;.
  <br/>
  See <b>cryptsetup-status</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="RESIZE"><a class="permalink" href="#RESIZE">RESIZE</a></h2>
<p class="Pp"><b>resize &lt;name&gt;</b></p>
<p class="Pp">Resizes an active mapping &lt;name&gt;.
  <br/>
  See <b>cryptsetup-resize</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="REFRESH"><a class="permalink" href="#REFRESH">REFRESH</a></h2>
<p class="Pp"><b>refresh &lt;name&gt;</b></p>
<p class="Pp">Refreshes parameters of active mapping &lt;name&gt;.
  <br/>
  See <b>cryptsetup-refresh</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="REENCRYPT"><a class="permalink" href="#REENCRYPT">REENCRYPT</a></h2>
<p class="Pp"><b>reencrypt &lt;device&gt; or --active-name &lt;name&gt;
    [&lt;new_name&gt;]</b></p>
<p class="Pp">Run LUKS device reencryption.
  <br/>
  See <b>cryptsetup-reencrypt</b>(8).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PLAIN_MODE"><a class="permalink" href="#PLAIN_MODE">PLAIN
  MODE</a></h1>
<p class="Pp">Plain dm-crypt encrypts the device sector-by-sector with a single,
    non-salted hash of the passphrase. No checks are performed, no metadata is
    used. There is no formatting operation. When the raw device is mapped
    (opened), the usual device operations can be used on the mapped device,
    including filesystem creation. Mapped devices usually reside in
    /dev/mapper/&lt;name&gt;.</p>
<p class="Pp">The following are valid plain device type actions:</p>
<section class="Ss">
<h2 class="Ss" id="OPEN~2"><a class="permalink" href="#OPEN~2">OPEN</a></h2>
<p class="Pp"><b>open --type plain &lt;device&gt; &lt;name&gt;</b>
  <br/>
  create &lt;name&gt; &lt;device&gt; (<b>OBSOLETE syntax</b>)</p>
<p class="Pp">Opens (creates a mapping with) &lt;name&gt; backed by device
    &lt;device&gt;.
  <br/>
  See <b>cryptsetup-open</b>(8).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LUKS_EXTENSION"><a class="permalink" href="#LUKS_EXTENSION">LUKS
  EXTENSION</a></h1>
<p class="Pp">LUKS, the Linux Unified Key Setup, is a standard for disk
    encryption. It adds a standardized header at the start of the device, a
    key-slot area directly behind the header and the bulk data area behind that.
    The whole set is called a 'LUKS container'. The device that a LUKS container
    resides on is called a 'LUKS device'. For most purposes, both terms can be
    used interchangeably. But note that when the LUKS header is at a nonzero
    offset in a device, then the device is not a LUKS device anymore, but has a
    LUKS container stored in it at an offset.</p>
<p class="Pp">LUKS can manage multiple passphrases that can be individually
    revoked or changed and that can be securely scrubbed from persistent media
    due to the use of anti-forensic stripes. Passphrases are protected against
    brute-force and dictionary attacks by Password-Based Key Derivation Function
    (PBKDF).</p>
<p class="Pp">LUKS2 is a new version of header format that allows additional
    extensions like different PBKDF algorithm or authenticated encryption. You
    can format device with LUKS2 header if you specify <b>--type luks2</b> in
    <b>luksFormat</b> command. For activation, the format is already recognized
    automatically.</p>
<p class="Pp">Each passphrase, also called a <b>key</b> in this document, is
    associated with one of 8 key-slots. Key operations that do not specify a
    slot affect the first slot that matches the supplied passphrase or the first
    empty slot if a new passphrase is added.</p>
<p class="Pp">The <b>&lt;device&gt;</b> parameter can also be specified by a
    LUKS UUID in the format UUID=&lt;uuid&gt;. Translation to real device name
    uses symlinks in /dev/disk/by-uuid directory.</p>
<p class="Pp">To specify a detached header, the <b>--header</b> parameter can be
    used in all LUKS commands and always takes precedence over the positional
    <b>&lt;device&gt;</b> parameter.</p>
<p class="Pp">The following are valid LUKS actions:</p>
<section class="Ss">
<h2 class="Ss" id="FORMAT"><a class="permalink" href="#FORMAT">FORMAT</a></h2>
<p class="Pp"><b>luksFormat &lt;device&gt; [&lt;key file&gt;]</b></p>
<p class="Pp">Initializes a LUKS partition and sets the initial passphrase (for
    key-slot 0).
  <br/>
  See <b>cryptsetup-luksFormat</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="OPEN~3"><a class="permalink" href="#OPEN~3">OPEN</a></h2>
<p class="Pp"><b>open --type luks &lt;device&gt; &lt;name&gt;</b>
  <br/>
  luksOpen &lt;device&gt; &lt;name&gt; (<b>old syntax</b>)</p>
<p class="Pp">Opens the LUKS device &lt;device&gt; and sets up a mapping
    &lt;name&gt; after successful verification of the supplied passphrase.
  <br/>
  See <b>cryptsetup-open</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SUSPEND"><a class="permalink" href="#SUSPEND">SUSPEND</a></h2>
<p class="Pp"><b>luksSuspend &lt;name&gt;</b></p>
<p class="Pp">Suspends an active device (all IO operations will block and
    accesses to the device will wait indefinitely) and wipes the encryption key
    from kernel memory.
  <br/>
  See <b>cryptsetup-luksSuspend</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="RESUME"><a class="permalink" href="#RESUME">RESUME</a></h2>
<p class="Pp"><b>luksResume &lt;name&gt;</b></p>
<p class="Pp">Resumes a suspended device and reinstates the encryption key.
  <br/>
  See <b>cryptsetup-luksResume</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ADD_KEY"><a class="permalink" href="#ADD_KEY">ADD
  KEY</a></h2>
<p class="Pp"><b>luksAddKey &lt;device&gt; [&lt;key file with new
  key&gt;]</b></p>
<p class="Pp">Adds a new passphrase using an existing passphrase.
  <br/>
  See <b>cryptsetup-luksAddKey</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="REMOVE_KEY"><a class="permalink" href="#REMOVE_KEY">REMOVE
  KEY</a></h2>
<p class="Pp"><b>luksRemoveKey &lt;device&gt; [&lt;key file with passphrase to
    be removed&gt;]</b></p>
<p class="Pp">Removes the supplied passphrase from the LUKS device.
  <br/>
  See <b>cryptsetup-luksRemoveKey</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CHANGE_KEY"><a class="permalink" href="#CHANGE_KEY">CHANGE
  KEY</a></h2>
<p class="Pp"><b>luksChangeKey &lt;device&gt; [&lt;new key file&gt;]</b></p>
<p class="Pp">Changes an existing passphrase.
  <br/>
  See <b>cryptsetup-luksChangeKey</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CONVERT_KEY"><a class="permalink" href="#CONVERT_KEY">CONVERT
  KEY</a></h2>
<p class="Pp"><b>luksConvertKey &lt;device&gt;</b></p>
<p class="Pp">Converts an existing LUKS2 keyslot to new PBKDF parameters.
  <br/>
  See <b>cryptsetup-luksConvertKey</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="KILL_SLOT"><a class="permalink" href="#KILL_SLOT">KILL
  SLOT</a></h2>
<p class="Pp"><b>luksKillSlot &lt;device&gt; &lt;key slot number&gt;</b></p>
<p class="Pp">Wipe the key-slot number &lt;key slot&gt; from the LUKS device.
  <br/>
  See <b>cryptsetup-luksKillSlot</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ERASE"><a class="permalink" href="#ERASE">ERASE</a></h2>
<p class="Pp"><b>erase &lt;device&gt;</b>
  <br/>
  luksErase &lt;device&gt; (<b>old syntax</b>)</p>
<p class="Pp">Erase all keyslots and make the LUKS container permanently
    inaccessible.
  <br/>
  See <b>cryptsetup-erase</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="UUID"><a class="permalink" href="#UUID">UUID</a></h2>
<p class="Pp"><b>luksUUID &lt;device&gt;</b></p>
<p class="Pp">Print or set the UUID of a LUKS device.
  <br/>
  See <b>cryptsetup-luksUUID</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="IS_LUKS"><a class="permalink" href="#IS_LUKS">IS
  LUKS</a></h2>
<p class="Pp"><b>isLuks &lt;device&gt;</b></p>
<p class="Pp">Returns true, if &lt;device&gt; is a LUKS device, false otherwise.
  <br/>
  See <b>cryptsetup-isLuks</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DUMP"><a class="permalink" href="#DUMP">DUMP</a></h2>
<p class="Pp"><b>luksDump &lt;device&gt;</b></p>
<p class="Pp">Dump the header information of a LUKS device.
  <br/>
  See <b>cryptsetup-luksDump</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HEADER_BACKUP"><a class="permalink" href="#HEADER_BACKUP">HEADER
  BACKUP</a></h2>
<p class="Pp"><b>luksHeaderBackup &lt;device&gt; --header-backup-file
    &lt;file&gt;</b></p>
<p class="Pp">Stores a binary backup of the LUKS header and keyslot area.
  <br/>
  See <b>cryptsetup-luksHeaderBackup</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HEADER_RESTORE"><a class="permalink" href="#HEADER_RESTORE">HEADER
  RESTORE</a></h2>
<p class="Pp"><b>luksHeaderRestore &lt;device&gt; --header-backup-file
    &lt;file&gt;</b></p>
<p class="Pp">Restores a binary backup of the LUKS header and keyslot area from
    the specified file.
  <br/>
  See <b>cryptsetup-luksHeaderRestore</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="TOKEN"><a class="permalink" href="#TOKEN">TOKEN</a></h2>
<p class="Pp"><b>token &lt;add|remove|import|export&gt; &lt;device&gt;</b></p>
<p class="Pp">Manipulate token objects used for obtaining passphrases.
  <br/>
  See <b>cryptsetup-token</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CONVERT"><a class="permalink" href="#CONVERT">CONVERT</a></h2>
<p class="Pp"><b>convert &lt;device&gt; --type &lt;format&gt;</b></p>
<p class="Pp">Converts the device between LUKS1 and LUKS2 format (if possible).
  <br/>
  See <b>cryptsetup-convert</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CONFIG"><a class="permalink" href="#CONFIG">CONFIG</a></h2>
<p class="Pp"><b>config &lt;device&gt;</b></p>
<p class="Pp">Set permanent configuration options (store to LUKS header).
  <br/>
  See <b>cryptsetup-config</b>(8).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LOOP"><a class="permalink" href="#LOOP">LOOP-AES
  EXTENSION</a></h1>
<p class="Pp">cryptsetup supports mapping loop-AES encrypted partition using a
    compatibility mode.</p>
<section class="Ss">
<h2 class="Ss" id="OPEN~4"><a class="permalink" href="#OPEN~4">OPEN</a></h2>
<p class="Pp"><b>open --type loopaes &lt;device&gt; &lt;name&gt; --key-file
    &lt;keyfile&gt;</b>
  <br/>
  loopaesOpen &lt;device&gt; &lt;name&gt; --key-file &lt;keyfile&gt; (<b>old
    syntax</b>)</p>
<p class="Pp">Opens the loop-AES &lt;device&gt; and sets up a mapping
    &lt;name&gt;.
  <br/>
  See <b>cryptsetup-open</b>(8).</p>
<p class="Pp">See also section 7 of the FAQ and <i>loop-AES</i>
    &lt;http://loop-aes.sourceforge.net&gt; for more information regarding
    loop-AES.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TCRYPT_(TRUECRYPT_AND_VERACRYPT_COMPATIBLE)_EXTENSION"><a class="permalink" href="#TCRYPT_(TRUECRYPT_AND_VERACRYPT_COMPATIBLE)_EXTENSION">TCRYPT
  (TRUECRYPT AND VERACRYPT COMPATIBLE) EXTENSION</a></h1>
<p class="Pp">cryptsetup supports mapping of TrueCrypt, tcplay or VeraCrypt
    encrypted partition using a native Linux kernel API. Header formatting and
    TCRYPT header change is not supported, cryptsetup never changes TCRYPT
    header on-device.</p>
<p class="Pp">TCRYPT extension requires kernel userspace crypto API to be
    available (introduced in Linux kernel 2.6.38). If you are configuring kernel
    yourself, enable &quot;User-space interface for symmetric key cipher
    algorithms&quot; in &quot;Cryptographic API&quot; section
    (CRYPTO_USER_API_SKCIPHER .config option).</p>
<p class="Pp">Because TCRYPT header is encrypted, you have to always provide
    valid passphrase and keyfiles.</p>
<p class="Pp">Cryptsetup should recognize all header variants, except legacy
    cipher chains using LRW encryption mode with 64 bits encryption block
    (namely Blowfish in LRW mode is not recognized, this is limitation of kernel
    crypto API).</p>
<p class="Pp">VeraCrypt is extension of TrueCrypt header with increased
    iteration count so unlocking can take quite a lot of time.</p>
<p class="Pp">To open a VeraCrypt device with a custom Personal Iteration
    Multiplier (PIM) value, use either the <b>--veracrypt-pim=&lt;PIM&gt;</b>
    option to directly specify the PIM on the command- line or use
    <b>--veracrypt-query-pim</b> to be prompted for the PIM.</p>
<p class="Pp">The PIM value affects the number of iterations applied during key
    derivation. Please refer to <i>PIM</i>
    &lt;https://www.veracrypt.fr/en/Personal%20Iterations%20Multiplier%20%28PIM%29.html&gt;
    for more detailed information.</p>
<p class="Pp">If you need to disable VeraCrypt device support, use
    <b>--disable-veracrypt</b> option.</p>
<p class="Pp"><b>NOTE:</b> Activation with <b>tcryptOpen</b> is supported only
    for cipher chains using LRW or XTS encryption modes.</p>
<p class="Pp">The <b>tcryptDump</b> command should work for all recognized
    TCRYPT devices and doesn&#x2019;t require superuser privilege.</p>
<p class="Pp">To map system device (device with boot loader where the whole
    encrypted system resides) use <b>--tcrypt-system</b> option. You can use
    partition device as the parameter (parameter must be real partition device,
    not an image in a file), then only this partition is mapped.</p>
<p class="Pp">If you have the whole TCRYPT device as a file image and you want
    to map multiple partition encrypted with system encryption, please create
    loopback mapping with partitions first (<b>losetup -P</b>, see
    <b>losetup(8)</b> man page for more info), and use loop partition as the
    device parameter.</p>
<p class="Pp">If you use the whole base device as a parameter, one device for
    the whole system encryption is mapped. This mode is available only for
    backward compatibility with older cryptsetup versions which mapped TCRYPT
    system encryption using the whole device.</p>
<p class="Pp">To use hidden header (and map hidden device, if available), use
    <b>--tcrypt-hidden</b> option.</p>
<p class="Pp">To explicitly use backup (secondary) header, use
    <b>--tcrypt-backup</b> option.</p>
<p class="Pp"><b>NOTE:</b> There is no protection for a hidden volume if the
    outer volume is mounted. The reason is that if there were any protection, it
    would require some metadata describing what to protect in the outer volume
    and the hidden volume would become detectable.</p>
<section class="Ss">
<h2 class="Ss" id="OPEN~5"><a class="permalink" href="#OPEN~5">OPEN</a></h2>
<p class="Pp"><b>open --type tcrypt &lt;device&gt; &lt;name&gt;</b>
  <br/>
  tcryptOpen_ &lt;device&gt; &lt;name&gt; (<b>old syntax</b>)</p>
<p class="Pp">Opens the TCRYPT (a TrueCrypt-compatible) &lt;device&gt; and sets
    up a mapping &lt;name&gt;.
  <br/>
  See <b>cryptsetup-open</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DUMP~2"><a class="permalink" href="#DUMP~2">DUMP</a></h2>
<p class="Pp"><b>tcryptDump &lt;device&gt;</b></p>
<p class="Pp">Dump the header information of a TCRYPT device.
  <br/>
  See <b>cryptsetup-tcryptDump</b>(8).</p>
<p class="Pp">See also <i></i><b>TrueCrypt</b><i></i><b>
    &lt;https://en.wikipedia.org/wiki/TrueCrypt&gt;</b> <b>and</b>
    <b></b><i></i><b>VeraCrypt</b><i></i><b>
    &lt;https://en.wikipedia.org/wiki/VeraCrypt&gt;</b> <b>pages for more
    information.</b></p>
<p class="Pp">Please note that cryptsetup does not use TrueCrypt or VeraCrypt
    code, please report all problems related to this compatibility extension to
    the cryptsetup project.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BITLK_(WINDOWS_BITLOCKER_COMPATIBLE)_EXTENSION"><a class="permalink" href="#BITLK_(WINDOWS_BITLOCKER_COMPATIBLE)_EXTENSION">BITLK
  (WINDOWS BITLOCKER COMPATIBLE) EXTENSION</a></h1>
<p class="Pp">cryptsetup supports mapping of BitLocker and BitLocker to Go
    encrypted partition using a native Linux kernel API. Header formatting and
    BITLK header changes are not supported, cryptsetup never changes BITLK
    header on-device.</p>
<p class="Pp">BITLK extension requires kernel userspace crypto API to be
    available (for details see TCRYPT section).</p>
<p class="Pp">Cryptsetup should recognize all BITLK header variants, except
    legacy header used in Windows Vista systems and partially decrypted
    BitLocker devices. Activation of legacy devices encrypted in CBC mode
    requires at least Linux kernel version 5.3 and for devices using Elephant
    diffuser kernel 5.6.</p>
<p class="Pp">The <b>bitlkDump</b> command should work for all recognized BITLK
    devices and doesn&#x2019;t require superuser privilege.</p>
<p class="Pp">For unlocking with the <b>open</b> a password or a recovery
    passphrase or a startup key must be provided.</p>
<p class="Pp">Additionally unlocking using volume key is supported. You must
    provide BitLocker Full Volume Encryption Key (FVEK) using the
    --volume-key-file option. The key must be decrypted and without the header
    (only 128/256/512 bits of key data depending on used cipher and mode).</p>
<p class="Pp">Other unlocking methods (TPM, SmartCard) are not supported.</p>
<section class="Ss">
<h2 class="Ss" id="OPEN~6"><a class="permalink" href="#OPEN~6">OPEN</a></h2>
<p class="Pp"><b>open --type bitlk &lt;device&gt; &lt;name&gt;</b>
  <br/>
  bitlkOpen &lt;device&gt; &lt;name&gt; (<b>old syntax</b>)</p>
<p class="Pp">Opens the BITLK (a BitLocker-compatible) &lt;device&gt; and sets
    up a mapping &lt;name&gt;.
  <br/>
  See <b>cryptsetup-open</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DUMP~3"><a class="permalink" href="#DUMP~3">DUMP</a></h2>
<p class="Pp"><b>bitlkDump &lt;device&gt;</b></p>
<p class="Pp">Dump the header information of a BITLK device.
  <br/>
  See <b>cryptsetup-bitlkDump</b>(8).</p>
<p class="Pp">Please note that cryptsetup does not use any Windows BitLocker
    code, please report all problems related to this compatibility extension to
    the cryptsetup project.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FVAULT2_(APPLE_MACOS_FILEVAULT2_COMPATIBLE)_EXTENSION"><a class="permalink" href="#FVAULT2_(APPLE_MACOS_FILEVAULT2_COMPATIBLE)_EXTENSION">FVAULT2
  (APPLE MACOS FILEVAULT2 COMPATIBLE) EXTENSION</a></h1>
<p class="Pp">cryptsetup supports the mapping of FileVault2 (FileVault2
    full-disk encryption) by Apple for the macOS operating system using a native
    Linux kernel API.</p>
<p class="Pp"><b>NOTE:</b> cryptsetup supports only FileVault2 based on Core
    Storage and HFS+ filesystem (introduced in MacOS X 10.7 Lion). It does NOT
    support the new version of FileVault based on the APFS filesystem used in
    recent macOS versions.</p>
<p class="Pp">Header formatting and FVAULT2 header changes are not supported;
    cryptsetup never changes the FVAULT2 header on-device.</p>
<p class="Pp">FVAULT2 extension requires kernel userspace crypto API to be
    available (for details, see TCRYPT section) and kernel driver for HFS+
    (hfsplus) filesystem.</p>
<p class="Pp">Cryptsetup should recognize the basic configuration for portable
    drives.</p>
<p class="Pp">The <b>fvault2Dump</b> command should work for all recognized
    FVAULT2 devices and doesn&#x2019;t require superuser privilege.</p>
<p class="Pp">For unlocking with the <b>open</b>, a password must be provided.
    Other unlocking methods are not supported.</p>
<section class="Ss">
<h2 class="Ss" id="OPEN~7"><a class="permalink" href="#OPEN~7">OPEN</a></h2>
<p class="Pp"><b>open --type fvault2 &lt;device&gt; &lt;name&gt;</b>
  <br/>
  fvault2Open &lt;device&gt; &lt;name&gt; (<b>old syntax</b>)</p>
<p class="Pp">Opens the FVAULT2 (a FileVault2-compatible) &lt;device&gt;
    (usually the second partition on the device) and sets up a mapping
    &lt;name&gt;.
  <br/>
  See <b>cryptsetup-open</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DUMP~4"><a class="permalink" href="#DUMP~4">DUMP</a></h2>
<p class="Pp"><b>fvault2Dump &lt;device&gt;</b></p>
<p class="Pp">Dump the header information of an FVAULT2 device.
  <br/>
  See <b>cryptsetup-fvault2Dump</b>(8).</p>
<p class="Pp">Note that cryptsetup does not use any macOS code or proprietary
    specifications. Please report all problems related to this compatibility
    extension to the cryptsetup project.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MISCELLANEOUS_ACTIONS"><a class="permalink" href="#MISCELLANEOUS_ACTIONS">MISCELLANEOUS
  ACTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="REPAIR"><a class="permalink" href="#REPAIR">REPAIR</a></h2>
<p class="Pp"><b>repair &lt;device&gt;</b></p>
<p class="Pp">Tries to repair the device metadata if possible. Currently
    supported only for LUKS device type.
  <br/>
  See <b>cryptsetup-repair</b>(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="BENCHMARK"><a class="permalink" href="#BENCHMARK">BENCHMARK</a></h2>
<p class="Pp"><b>benchmark &lt;options&gt;</b></p>
<p class="Pp">Benchmarks ciphers and KDF (key derivation function).
  <br/>
  See <b>cryptsetup-benchmark</b>(8).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PLAIN_DM"><a class="permalink" href="#PLAIN_DM">PLAIN
  DM-CRYPT OR LUKS?</a></h1>
<p class="Pp">Unless you understand the cryptographic background well, use LUKS.
    With plain dm-crypt there are a number of possible user errors that
    massively decrease security. While LUKS cannot fix them all, it can lessen
    the impact for many of them.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNINGS"><a class="permalink" href="#WARNINGS">WARNINGS</a></h1>
<p class="Pp">A lot of good information on the risks of using encrypted storage,
    on handling problems and on security aspects can be found in the Cryptsetup
    FAQ. Read it. Nonetheless, some risks deserve to be mentioned here.</p>
<p class="Pp"><b>Backup:</b> Storage media die. Encryption has no influence on
    that. Backup is mandatory for encrypted data as well, if the data has any
    worth. See the Cryptsetup FAQ for advice on how to do a backup of an
    encrypted volume.</p>
<p class="Pp"><b>Character encoding:</b> If you enter a passphrase with special
    symbols, the passphrase can change depending on character encoding. Keyboard
    settings can also change, which can make blind input hard or impossible. For
    example, switching from some ASCII 8-bit variant to UTF-8 can lead to a
    different binary encoding and hence different passphrase seen by cryptsetup,
    even if what you see on the terminal is exactly the same. It is therefore
    highly recommended to select passphrase characters only from 7-bit ASCII, as
    the encoding for 7-bit ASCII stays the same for all ASCII variants and
    UTF-8.</p>
<p class="Pp"><b>LUKS header:</b> If the header of a LUKS volume gets damaged,
    all data is permanently lost unless you have a header-backup. If a key-slot
    is damaged, it can only be restored from a header-backup or if another
    active key-slot with known passphrase is undamaged. Damaging the LUKS header
    is something people manage to do with surprising frequency. This risk is the
    result of a trade-off between security and safety, as LUKS is designed for
    fast and secure wiping by just overwriting header and key-slot area.</p>
<p class="Pp"><b>Previously used partitions:</b> If a partition was previously
    used, it is a very good idea to wipe filesystem signatures, data, etc.
    before creating a LUKS or plain dm-crypt container on it. For a quick
    removal of filesystem signatures, use <b>wipefs</b>(8). Take care though
    that this may not remove everything. In particular, MD RAID signatures at
    the end of a device may survive. It also does not remove data. For a full
    wipe, overwrite the whole partition before container creation. If you do not
    know how to do that, the cryptsetup FAQ describes several options.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Example 1: Create LUKS 2 container on block device /dev/sdX.</p>
<div class="Bd-indent">sudo cryptsetup --type luks2 luksFormat /dev/sdX</div>
<p class="Pp">Example 2: Add an additional passphrase to key slot 5.</p>
<div class="Bd-indent">sudo cryptsetup luksAddKey --key-slot 5 /dev/sdX</div>
<p class="Pp">Example 3: Create LUKS header backup and save it to file.</p>
<div class="Bd-indent">sudo cryptsetup luksHeaderBackup /dev/sdX
  --header-backup-file /var/tmp/NameOfBackupFile</div>
<p class="Pp">Example 4: Open LUKS container on /dev/sdX and map it to
    sdX_crypt.</p>
<div class="Bd-indent">sudo cryptsetup open /dev/sdX sdX_crypt</div>
<p class="Pp"><b>WARNING: The command in example 5 will erase all key
  slots.</b></p>
<div class="Bd-indent">Your cannot use your LUKS container afterward anymore
  unless you have a backup to restore.</div>
<p class="Pp">Example 5: Erase all key slots on /dev/sdX.</p>
<div class="Bd-indent">sudo cryptsetup erase /dev/sdX</div>
<p class="Pp">Example 6: Restore LUKS header from backup file.</p>
<div class="Bd-indent">sudo cryptsetup luksHeaderRestore /dev/sdX
  --header-backup-file /var/tmp/NameOfBackupFile</div>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_CODES"><a class="permalink" href="#RETURN_CODES">RETURN
  CODES</a></h1>
<p class="Pp">Cryptsetup returns <b>0</b> on success and a non-zero value on
    error.</p>
<p class="Pp">Error codes are: <b>1</b> wrong parameters, <b>2</b> no permission
    (bad passphrase), <b>3</b> out of memory, <b>4</b> wrong device specified,
    <b>5</b> device already exists or device is busy.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Passphrase_processing_for_PLAIN_mode"><a class="permalink" href="#Passphrase_processing_for_PLAIN_mode">Passphrase
  processing for PLAIN mode</a></h2>
<p class="Pp">Note that no iterated hashing or salting is done in plain mode. If
    hashing is done, it is a single direct hash. This means that low-entropy
    passphrases are easy to attack in plain mode.</p>
<p class="Pp"><b>From a terminal</b>: The passphrase is read until the first
    newline, i.e. '\n'. The input without the newline character is processed
    with the default hash or the hash specified with --hash. The hash result
    will be truncated to the key size of the used cipher, or the size specified
    with -s.</p>
<p class="Pp"><b>From stdin</b>: Reading will continue until a newline (or until
    the maximum input size is reached), with the trailing newline stripped. The
    maximum input size is defined by the same compiled-in default as for the
    maximum key file size and can be overwritten using --keyfile-size
  option.</p>
<p class="Pp">The data read will be hashed with the default hash or the hash
    specified with --hash. The hash result will be truncated to the key size of
    the used cipher, or the size specified with -s.</p>
<p class="Pp">Note that if --key-file=- is used for reading the key from stdin,
    trailing newlines are not stripped from the input.</p>
<p class="Pp">If &quot;plain&quot; is used as argument to --hash, the input data
    will not be hashed. Instead, it will be zero padded (if shorter than the key
    size) or truncated (if longer than the key size) and used directly as the
    binary key. This is useful for directly specifying a binary key. No warning
    will be given if the amount of data read from stdin is less than the key
    size.</p>
<p class="Pp"><b>From a key file</b>: It will be truncated to the key size of
    the used cipher or the size given by -s and directly used as a binary
  key.</p>
<p class="Pp"><b>WARNING</b>: The --hash argument is being ignored. The --hash
    option is usable only for stdin input in plain mode.</p>
<p class="Pp">If the key file is shorter than the key, cryptsetup will quit with
    an error. The maximum input size is defined by the same compiled-in default
    as for the maximum key file size and can be overwritten using --keyfile-size
    option.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Passphrase_processing_for_LUKS"><a class="permalink" href="#Passphrase_processing_for_LUKS">Passphrase
  processing for LUKS</a></h2>
<p class="Pp">LUKS uses PBKDF to protect against dictionary attacks and to give
    some protection to low-entropy passphrases (see cryptsetup FAQ).</p>
<p class="Pp"><b>From a terminal</b>: The passphrase is read until the first
    newline and then processed by PBKDF2 without the newline character.</p>
<p class="Pp"><b>From stdin</b>: LUKS will read passphrases from stdin up to the
    first newline character or the compiled-in maximum key file length. If
    --keyfile-size is given, it is ignored.</p>
<p class="Pp"><b>From key file</b>: The complete keyfile is read up to the
    compiled-in maximum size. Newline characters do not terminate the input. The
    --keyfile-size option can be used to limit what is read.</p>
<p class="Pp"><b>Passphrase processing</b>: Whenever a passphrase is added to a
    LUKS header (luksAddKey, luksFormat), the user may specify how much the time
    the passphrase processing should consume. The time is used to determine the
    iteration count for PBKDF2 and higher times will offer better protection for
    low-entropy passphrases, but open will take longer to complete. For
    passphrases that have entropy higher than the used key length, higher
    iteration times will not increase security.</p>
<p class="Pp">The default setting of one or two seconds is sufficient for most
    practical cases. The only exception is a low-entropy passphrase used on a
    device with a slow CPU, as this will result in a low iteration count. On a
    slow device, it may be advisable to increase the iteration time using the
    --iter-time option in order to obtain a higher iteration count. This does
    slow down all later luksOpen operations accordingly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Incoherent_behavior_for_invalid_passphrases/keys"><a class="permalink" href="#Incoherent_behavior_for_invalid_passphrases/keys">Incoherent
  behavior for invalid passphrases/keys</a></h2>
<p class="Pp">LUKS checks for a valid passphrase when an encrypted partition is
    unlocked. The behavior of plain dm-crypt is different. It will always
    decrypt with the passphrase given. If the given passphrase is wrong, the
    device mapped by plain dm-crypt will essentially still contain encrypted
    data and will be unreadable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Supported_ciphers,_modes,_hashes_and_key_sizes"><a class="permalink" href="#Supported_ciphers,_modes,_hashes_and_key_sizes">Supported
  ciphers, modes, hashes and key sizes</a></h2>
<p class="Pp">The available combinations of ciphers, modes, hashes and key sizes
    depend on kernel support. See /proc/crypto for a list of available options.
    You might need to load additional kernel crypto modules in order to get more
    options.</p>
<p class="Pp">For the --hash option, if the crypto backend is libgcrypt, then
    all algorithms supported by the gcrypt library are available. For other
    crypto backends, some algorithms may be missing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes_on_passphrases"><a class="permalink" href="#Notes_on_passphrases">Notes
  on passphrases</a></h2>
<p class="Pp">Mathematics can&#x2019;t be bribed. Make sure you keep your
    passphrases safe. There are a few nice tricks for constructing a fallback,
    when suddenly out of the blue, your brain refuses to cooperate. These
    fallbacks need LUKS, as it&#x2019;s only possible with LUKS to have multiple
    passphrases. Still, if your attacker model does not prevent it, storing your
    passphrase in a sealed envelope somewhere may be a good idea as well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes_on_Random_Number_Generators"><a class="permalink" href="#Notes_on_Random_Number_Generators">Notes
  on Random Number Generators</a></h2>
<p class="Pp">Random Number Generators (RNG) used in cryptsetup are always the
    kernel RNGs without any modifications or additions to data stream
  produced.</p>
<p class="Pp">There are two types of randomness cryptsetup/LUKS needs. One type
    (which always uses /dev/urandom) is used for salts, the AF splitter and for
    wiping deleted keyslots.</p>
<p class="Pp">The second type is used for the volume key. You can switch between
    using /dev/random and /dev/urandom here, see <b>--use-random</b> and
    <b>--use-urandom</b> options. Using /dev/random on a system without enough
    entropy sources can cause <b>luksFormat</b> to block until the requested
    amount of random data is gathered. In a low-entropy situation (embedded
    system), this can take a very long time and potentially forever. At the same
    time, using /dev/urandom in a low-entropy situation will produce low-quality
    keys. This is a serious problem, but solving it is out of scope for a mere
    man-page. See <b>urandom(4)</b> for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Authenticated_disk_encryption_(EXPERIMENTAL)"><a class="permalink" href="#Authenticated_disk_encryption_(EXPERIMENTAL)">Authenticated
  disk encryption (EXPERIMENTAL)</a></h2>
<p class="Pp">Since Linux kernel version 4.12 dm-crypt supports authenticated
    disk encryption.</p>
<p class="Pp">Normal disk encryption modes are length-preserving (plaintext
    sector is of the same size as a ciphertext sector) and can provide only
    confidentiality protection, but not cryptographically sound data integrity
    protection.</p>
<p class="Pp">Authenticated modes require additional space per-sector for
    authentication tag and use Authenticated Encryption with Additional Data
    (AEAD) algorithms.</p>
<p class="Pp">If you configure LUKS2 device with data integrity protection,
    there will be an underlying dm-integrity device, which provides additional
    per-sector metadata space and also provide data journal protection to ensure
    atomicity of data and metadata update. Because there must be additional
    space for metadata and journal, the available space for the device will be
    smaller than for length-preserving modes.</p>
<p class="Pp">The dm-crypt device then resides on top of such a dm-integrity
    device. All activation and deactivation of this device stack is performed by
    cryptsetup, there is no difference in using <b>luksOpen</b> for integrity
    protected devices. If you want to format LUKS2 device with data integrity
    protection, use <b>--integrity</b> option.</p>
<p class="Pp">Since dm-integrity doesn&#x2019;t support discards (TRIM),
    dm-crypt device on top of it inherits this, so integrity protection mode
    doesn&#x2019;t support discards either.</p>
<p class="Pp">Some integrity modes requires two independent keys (key for
    encryption and for authentication). Both these keys are stored in one LUKS
    keyslot.</p>
<p class="Pp"><b>WARNING:</b> All support for authenticated modes is
    experimental and there are only some modes available for now. Note that
    there are a very few authenticated encryption algorithms that are suitable
    for disk encryption. You also cannot use CRC32 or any other
    non-cryptographic checksums (other than the special integrity mode
    &quot;none&quot;). If for some reason you want to have integrity control
    without using authentication mode, then you should separately configure
    dm-integrity independently of LUKS2.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes_on_loopback_device_use"><a class="permalink" href="#Notes_on_loopback_device_use">Notes
  on loopback device use</a></h2>
<p class="Pp">Cryptsetup is usually used directly on a block device (disk
    partition or LVM volume). However, if the device argument is a file,
    cryptsetup tries to allocate a loopback device and map it into this file.
    This mode requires Linux kernel 2.6.25 or more recent which supports the
    loop autoclear flag (loop device is cleared on the last close
    automatically). Of course, you can always map a file to a loop-device
    manually. See the cryptsetup FAQ for an example.</p>
<p class="Pp">When device mapping is active, you can see the loop backing file
    in the status command output. Also see losetup(8).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="LUKS2_header_locking"><a class="permalink" href="#LUKS2_header_locking">LUKS2
  header locking</a></h2>
<p class="Pp">The LUKS2 on-disk metadata is updated in several steps and to
    achieve proper atomic update, there is a locking mechanism. For an image in
    file, code uses <b>flock(2)</b> system call. For a block device, lock is
    performed over a special file stored in a locking directory (by default
    <b>/run/cryptsetup</b>). The locking directory should be created with the
    proper security context by the distribution during the boot-up phase. Only
    LUKS2 uses locks, other formats do not use this mechanism.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="LUKS_on"><a class="permalink" href="#LUKS_on">LUKS on-disk
  format specification</a></h2>
<p class="Pp">For LUKS on-disk metadata specification see
    <i></i><b>LUKS1</b><i></i><b>
    &lt;https://gitlab.com/cryptsetup/cryptsetup/wikis/Specification&gt;</b>
    <b>and</b> <b></b><i></i><b>LUKS2</b><i></i><b>
    &lt;https://gitlab.com/cryptsetup/LUKS2-docs&gt;.</b></p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Cryptsetup is originally written by <i>Jana Saout</i>
    &lt;jana@saout.de&gt;.
  <br/>
  The LUKS extensions and original man page were written by <i>Clemens
    Fruhwirth</i> &lt;clemens@endorphin.org&gt;.
  <br/>
  Man page extensions by <i>Milan Broz</i> &lt;gmazyland@gmail.com&gt;.
  <br/>
  Man page rewrite and extension by <i>Arno Wagner</i>
  &lt;arno@wagner.name&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REPORTING_BUGS"><a class="permalink" href="#REPORTING_BUGS">REPORTING
  BUGS</a></h1>
<p class="Pp">Report bugs at <i></i><b>cryptsetup mailing list</b><i></i><b>
    &lt;cryptsetup@lists.linux.dev&gt;</b> <b>or in </b><b></b><i></i><b>Issues
    project section</b><i></i><b>
    &lt;https://gitlab.com/cryptsetup/cryptsetup/-/issues/new&gt;.</b></p>
<p class="Pp">Please attach output of the failed command with --debug option
    added.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><i></i><b>Cryptsetup FAQ</b><i></i><b>
    &lt;https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions&gt;</b></p>
<p class="Pp"><b>cryptsetup</b>(8), <b>integritysetup</b>(8) and
    <b>veritysetup</b>(8)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CRYPTSETUP"><a class="permalink" href="#CRYPTSETUP">CRYPTSETUP</a></h1>
<p class="Pp">Part of <i></i><b>cryptsetup project</b><i></i><b>
    &lt;https://gitlab.com/cryptsetup/cryptsetup/&gt;.</b></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date"><b>2023-02-09</b></td>
    <td class="foot-os"><b>cryptsetup 2.6.1</b></td>
  </tr>
</table>
</body>
</html>
